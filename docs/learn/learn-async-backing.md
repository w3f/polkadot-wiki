---
id: learn-async-backing
title: Asynchronous Backing
sidebar_label: Asynchronous Backing
description: A brief overview of asynchronous backing, and how it affects Polkadot's scalability.
keywords: [parachains, backing, parablock, perspective parachains, unincluded segments]
slug: ../learn-async-backing
---

import RPC from "./../../components/RPC-Connection";

:::info Learn about Parachain Consensus

To fully follow the material on this page, it is recommended to be familiar with the primary stages
of the [Parachain Protocol](./learn-parachains-protocol.md).

:::

In Polkadot, parablocks are generated by [collators](./learn-collator.md) on the parachain side and
sent to [validators](./learn-validator.md) on the relay chain side for backing.

:::info What is backing?

**Backing** refers to the process in which parablocks are verified by a subset of validators or
backing groups. It is an important step in the validation process for parablocks, as it is the first
line of defense in ensuring censorship resistance. Parablocks only need to be backed by one
validator, and as a consequence backing does not ensure parablock validity.

:::

Backed parablocks are sent to other validators for inclusion into the relay chain. Parablocks are
included when validators have attested to having received
[erasure coded chunks](./learn-parachains-protocol.md#erasure-codes) of the parablock data. Note
[candidate receipts](#candidate-receipt) and not the parablocks themselves are included in relay
blocks (but for simplicity we just refer to parablocks as being included). From the time they are
generated, parablocks must be anchored to a relay chain block called **relay parent**. The relay
parent is an input to parablock candidate generation. It provides necessary context to build the
next parablock. Note that the relay parent of a parablock and the relay block including that
parablock are always different.

## Synchronous Backing

Before diving into asynchronous backing, it is important to understand what synchronous backing is
and what its main limitations are. In synchronous backing, parablock generation is tightly coupled
to the relay chain's progression:

1. A new parablock can be produced after including the previous one (i.e. every 12 seconds).
2. Context to build the next parablock is drawn from the latest included parablock ancestor
3. The relay parent must be the latest relay chain block.

Because of (1) parablocks can be generated every other relay chain block (i.e. every 12 seconds).
Because of (2) generation of parablock `P` can only start when `P - 1` is included (there is no
[pipelining](#pipelining)). Because of (3) execution time can take maximum 0.5 seconds as parablock
`P` is rushing to be backed in the next 5.5 seconds (2 seconds needed for backing and the rest for
gossiping). Every parablock is backed in 6 seconds (one relay chain block), and included in the next
6 seconds (next relay chain block). Time from generation to inclusion is 12 seconds. This limits the
amount of data a collator can add to each parablock.

Note that parablock generation will choose the most recently received relay block as a relay parent,
although with imperfect network that may not be the same as the true most recent relay block. So, in
general, if relay block `R` is the relay parent of parablock `P`, then `P` could be backed in
`R + 1` and included in `R + 2`.

![sync-backing](../assets/sync-backing.png)

From left to right, parablock P1 is anchored to the relay parent R0 (showed with an `x`), backed
into the relay chain block R1, and included in R2. After the inclusion of P1, collators can start
generating P2 that must be anchored to the relay parent R2. Note that R2 will be the relay parent of
P2 if R2 is included on the relay chain and gossiped to the collator producing P2.

:::info Every collator also runs an attached relay chain full node

The attached relay node receives relay blocks via gossip. Then the relay node talks to the parachain
node through the `CollationGeneration` subsystem. R2 is gossiped to the relay full node attached to
the collator producing P2. Then `CollationGeneration` passes information about R2 to the collator
node. Finally, relay parent information from R2 informs the generation of candidate P2.

:::

Because P2 is rushing to be backed in 6 seconds into R3, collators have only 0.5 seconds to generate
it and present it to backing groups on the relay chain that will take approximately 2 seconds to
back it and some extra time for gossiping it (the whole process from collation to backing lasts 6
seconds). P2 is included in R4, which could be used as a relay parent for P3 (not shown). After 24
seconds P1 and P2 are included into the relay chain. Note how collators can start new parablocks
every 12 seconds, but only have 0.5 seconds to generate them.

## Asynchronous Backing

:::warning Disclaimer: Performance Measurements

Due to asynchronous backing not being fully implemented in a running production network, each
performance metric is not thoroughly tested nor guaranteed until proper benchmarking has occurred.

:::

### Synchronous vs. Asynchronous Backing

Below, a table showing the main differences between synchronous and asynchronous backing.

|                                            |                           Sync Backing                            |                                                                                  Async Backing                                                                                  |                   Async Backing Advantage                    |
| :----------------------------------------- | :---------------------------------------------------------------: | :-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------: |
| **Parablocks included every**              |                            12 seconds                             |                                                                                    6 seconds                                                                                    |            2x more throughput or 2x less latency             |
| **Parablock's maximum generation time**    |                            0.5 seconds                            |                                                              Recommended 2 seconds, but higher values are possible                                                              |                 4x more data in a parablock                  |
| **Relay parent**                           |                  Is the latest relay chain block                  |                                                                 Is not necessarily the latest relay chain block                                                                 | Collators can submit parablocks to backing groups in advance |
| **Collators can build on**                 | The most recent ancestor included in the latest relay chain block | An ancestor included in a relay chain block (not necessarily the latest), with augmented information from the latest ancestor in the [unincluded segment](#unincluded-segments) |      Collators can start building parablocks in advance      |
| **Number of unincluded parablocks**        |                             Only one                              |                                                           One, or more than one (depends on configuration parameters)                                                           |               More efficiency and scalability                |
| **Unincluded parablocks**                  |                       Cannot be re-proposed                       |                                                      Can be re-proposed if not successfully included in the first attempt                                                       |            Decrease wastage of unused blockspace             |
| **Parablock's Backing-to-inclusion time**  |                            12 seconds                             |                                                                                   12 seconds                                                                                    |                          No change                           |
| **Parablock's Inclusion-to-finality time** |                            30 seconds                             |                                                                                   30 seconds                                                                                    |                          No change                           |

In synchronous backing collators generate parablocks using context entirely pulled from the relay
chain. While in asynchronous backing collators use additional context from the
[unincluded segment](#unincluded-segments). Parablocks are included every 6 seconds because backing
of parablock `N + 1` and inclusion of parablock `N` can happen on the same relay chain bock
([pipelining](#pipelining)). However, as for synchronous backing, a parablock takes 12 seconds to
get backed and included, and from inclusion to finality there is an additional 30-second time
window.

Because the throughput is increased by 2x and parachains have 4x more time to generate blocks,
asynchronous backing is expected to deliver 8x more blockspace to parachains.

### Sync Backing as special case of Async Backing

Two parameters of asynchronous backing can be controlled by
[Governance](./learn-polkadot-opengov.md):

- [`max_candidate_depth`](https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L49):
  the number of parachain blocks a collator can produce that are not yet included in the relay
  chain.

- [`allowed_ancestry_len`](https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L54):
  the oldest relay chain parent a parachain block can be built on top of.

Values of zero for both correspond to synchronous backing: `max_candidate_depth = 0` means there can
be only one unincluded parablock at all times, and `allowed_ancestry_len = 0` means a parablock can
be built only on the latest relay parent for that parachain. Initial values will be set to 3 (4
unincluded parablocks at all times) and 2 (relay parent can be the third last).

### Async Backing Diagram

![async-backing](../assets/async-backing.png)

The diagram assumes:

- `max_candidate_depth = 2`, meaning that there can be a maximum of three unincluded parablocks at
  all times
- `allowed_ancestry_len = 1`, meaning parablocks can be anchored to the last or second-last relay
  parent (i.e. collators can start preparing parablocks 6 seconds in advance)

From left to right, parablock P1 is backed into the relay chain block R1 and included into R2. While
P1 undergoes backing, collators can already start to generate P2, which will have R0 as a relay
parent (showed with an `x`). Note how R0 can also be relay parent for P1 as long as in the
unincluded segment there is a maximum of three unincluded parablocks. Parablock P2 can be backed in
R2 (the same relay block where P1 is included) and included in R3. Collators can now use up to two
seconds to generate parablocks. And so on, P3 can be generated while P2 is checked by backing
groups, and P4 can be built while P3 undergoing backing. In 24 seconds, P1 to P3 are included into
the relay chain.

Note how there are always three unincluded parablocks at all times, i.e. compared to synchronous
backing there can be multiple unincluded parablocks (i.e. [pipelining](#pipelining)). For example,
when P1 undergoing inclusion, P2 and P3 are undergoing backing. Collators were able to generate
multiple unincluded parablocks because on their end they have the
[unincluded segment](#unincluded-segments), a local storage of not included parablock ancestors that
they can use to fetch information to build new parablocks. On the relay chain side
[perspective parachains](#prospective-parachains) repeats the work each unincluded segment does in
tracking candidates (as validators cannot trust the record kept on parachains).

Collating on top of unincluded parents means the only time limit to generate a parablock is how long
it takes to back it (2 seconds). The 6-second relay chain block delay includes a backing execution
timeout (2 seconds) and some time for network latency (time it takes to gossip messages across the
entire network). Thus, even if a collator has >2 seconds to produce a block, the validators will
still have ~2 seconds to check it.

## Terminology

### Candidate Receipt

Saying that a parablock has been included in a realy chain parent does not mean that the entire
parablock is in the relay chain block. Instead, **candidate receipt** consisting of the hash of the
parablock, state roots and ID info is placed on the parent block on the relay chain. The relay chain
does not access the entire state of a parachain but only the values that changed during that block
and the merkelized hashes of the unchanged values.

### Pipelining

Asynchronous backing is a feature that introduces
[pipelining](https://www.techtarget.com/whatis/definition/pipelining) to the parachain block
[generation, backing and inclusion](./learn-parachains-protocol.md). It is analogous to the logical
pipelining of processor instruction in "traditional" architectures, where some instructions may be
executed before others are complete. Instructions may also be executed in parallel, enabling
multiple processor parts to work on potentially different instructions simultaneously.

Bundles of state transitions represented as blocks may be processed similarly. In the context of
{{ polkadot: Polkadot :polkadot }}{{ kusama: Kusama :kusama }}, pipelining aims to increase the
throughput of the entire network by completing the backing and inclusion steps for different blocks
at the same time. Asynchronous backing does not just allow for pipelining within a single pipe (or
core). It lays the foundation for a large number of pipes (~10 cores) to run for the same parachain
at the same time. In that way we have two distinct new forms of parallel computation: having one
block backed and one included simultaneously using one core, and having having `n` blocks backed and
`n` blocks included simultaneously using `n` cores.

### Unincluded Segments

Unincluded segments are chains of candidate parablocks that have yet to be included in the relay
chain, i.e. they can contain parablocks at any stage pre-inclusion. An unincluded segment may thus
include candidates that are seconded, backable, or backed. Every parablock candidate recorded in the
unincluded segment is immediately advertised to validators to begin the backing process.

The backing process occurs on the relay chain, whereas unincluded segments live in the runtimes of
parachain collators. The core functionality that asynchronous backing brings is the ability to build
on these unincluded segments of block ancestors rather than building only on ancestors included in
the relay chain state.

The purpose of each unincluded segment is two fold:

- Make each parachain aware of when and at what depth it can build blocks that won't be rejected by
  the relay chain
- Provide critical context necessary to build parablocks with parent blocks that have yet to be
  included. The unincluded segment is all about building parablocks.

### Prospective Parachains

The purpose of
[prospective parachains](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html)
is two fold:

- Keep track of parablocks which have been submitted to backers but not yet included. This includes
  tracking the full unincluded ancestry of each parablock, without which it wouldn't be possible to
  verify their legitimacy.

- Look up and provide candidates which are children of the most recently included parablock for each
  parachain. These are taken as inputs to the availability process. Prospective parachains is all
  about tracking, storing, and providing candidates to the availability/inclusion step.

Prospective parachains essentially repeats the work each [unincluded segment](#unincluded-segments)
does in tracking candidates. Validators cannot simply trust the availability or validity of records
kept on parachains. Prospective parachains is the relay chain's record of all parablock candidates
undergoing the backing and inclusion process. It is the authoritative gate keeper for parablock
validity. Whereas the unincluded segment is a local record which allows parachains to produce blocks
which comply with the rules prospective parachains later enforces.

The unincluded segment lives in the parachain runtime, so it doesn't know or care about forks/other
parachains. Prospective parachains lives in the relay chain client. So it has to simultaneously keep
track of candidates from all forks of all parachains. It is as if you folded the unincluded segments
from every fork of every parachain into one giant data structure. When you fold unincluded segments
representing different chain forks together, they create a tree structure. Hence the term
[**fragment tree**](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html#fragment-trees).

A single unincluded segment tells a collator whether it can build on top of one fork of one
parachain. Prospective parachains tells a validator whether it should accept blocks built on top of
any fork from any parachain.

A parablock stops being a prospective parablock at the moment when it is included on chain. At that
point prospective parachains doesn't have to care about it anymore. Alternatively, a parablock's
relay parent can get too old before that parablock is included, in which case prospective parachains
can throw away the candidate.

## Learn More

This topic is evolving and being implemented at the moment, keep up to date using the following
resources:

- [Polkadot Roadmap Roundup](https://polkadot.network/blog/polkadot-roadmap-roundup) - Article by
  Rob Habermeier, Polkadot founder, details the plans for Polkadot for 2023.
- [Asynchronous Backing Spec & Tracking Issue](https://github.com/paritytech/polkadot/issues/3779) -
  The implementation tracking issue for asynchronous backing
- [Prospective Parachains Subsystem - The Polkadot Parachain Host Implementers' Guide](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html)
- Chapter 6.11. from Polkadot Blockchain Academy (PBA) lecture material:
  [Asynchronous Backing (Shallow)](https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-shallow/page.html)
- Chapter 6.15. from PBA lecture material:
  [Asynchronous Backing (Deep)](https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-deep/page.html)
- Polkadot Blog Post -
  [Asynchronous Backing: Elevating Polkadot's Performance and Scale](https://www.polkadot.network/blog/elevating-polkadots-performance-and-scale-with-asynchronous-backing)
