---
id: learn-async-backing
title: Asynchronous Backing
sidebar_label: Asynchronous Backing
description: A brief overview of asynchronous backing, and how it affects Polkadot's scalability.
keywords: [parachains, backing, parablock, perspective parachains, unincluded segments]
slug: ../learn-async-backing
---

import RPC from "./../../components/RPC-Connection";

:::info Learn about Parachain Consensus

To fully follow the material on this page, it is recommended to be familiar with the primary stages
of the [Parachain Protocol](./learn-parachains-protocol.md).

:::

In Polkadot, parablocks are generated by [collators](./learn-collator.md) on the parachain side and
sent to [validators](./learn-validator.md) on the relay chain side for backing.

:::info What is backing?

**Backing** refers to the process in which parablocks are verified by a subset of validators or
backing groups. It is an important step in the validation process for parablocks, as it is the first
line of defense in ensuring censorship resistance. Parablocks only need to be backed by one
validator, and as a consequence backing does not ensure parablock validity.

:::

Backed parablocks are sent to other validators for inclusion into the relay chain. Parablocks are
included when validators have attested to having received
[erasure coded chunks](./learn-parachains-protocol.md#erasure-codes) of the parablock data. Note
[candidate receipts](#candidate-receipt) and not the parablocks themselves are included in relay
blocks. Immediately after their generation and as soon as they enter the relay chain side,
parablocks must be anchored to a relay chain block called **relay parent**. Note that the relay
parent of a parablock and the relay block including that parablock are always different.

## Synchronous Backing

Before diving into asynchronous backing, it is important to understand what synchronous backing is
and what its main limitations are.

In synchronous backing, parablock generation is tightly coupled to the relay chain's progression on
a one-to-one basis. The following conditions must apply to get parablocks included into the relay
chains:

1. A new parablock can be produced after including the previous one (i.e. every 12 seconds).
2. The relay parent must be the latest relay chain block.
3. Every parablock is backed in 6 seconds (one relay chain block), and included in the next 6
   seconds (next relay chain block). Time from generation to inclusion is 12 seconds. This limits
   the amount of data a collator can add to each parablock.

Because of (1) parablocks can be generated every other relay chain block (i.e. every 12 seconds).
Because of (2) generation of parablock `N + 1` can only start when `N` is included (there is no
[pipelining](#pipelining)). Because of (3) execution time can take maximum 0.5 seconds as parablock
`N + 1` is rushing to be backed in the next 5.5 seconds.

The diagram below shows the pipelining table for asynchronous backing.

![sync-backing](../assets/sync-backing.png)

From left to right, parablock P1 is anchored to the relay parent R0, backed into the relay chain
block R1, and included in R2. After the inclusion of P1, collators can start generating P2 that must
to be anchored to the relay parent R2 (showed with an `x`). Because P2 is rushing to be backed in 6
seconds into R3, collators have only 0.5 seconds to generate it and present it to backing groups on
the relay chain (tick mark `|` on the horizontal line after the `x` shows the deadline for parablock
generation). P2 is included in R4, which will be used as a relay parent for P3 (not shown). After 24
seconds P1 and P2 are included into the relay chain. Note how collators can start new parablocks
every 12 seconds, but only have 0.5 seconds to generate them.

## Asynchronous Backing

:::warning Disclaimer: Performance Measurements

Due to asynchronous backing not being fully implemented in a running production network, each
performance metric is not thoroughly tested nor guaranteed until proper benchmarking has occurred.

:::

### Synchronous vs. Asynchronous Backing

Below, a table showing the main differences between synchronous and asynchronous backing.

|                                                                |            Sync Backing             |                                                                                         Async Backing                                                                                          |                   Async Backing Advantage                    |
| :------------------------------------------------------------- | :---------------------------------: | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | :----------------------------------------------------------: |
| **Parablocks included every**                                  |             12 seconds              |                                                                                           6 seconds                                                                                            |                        2x throughput                         |
| **Relay parent**                                               |   Is the latest relay chain block   |                                                                        Is not necessarily the latest relay chain block                                                                         | Collators can submit parablocks to backing groups in advance |
| **Collators can build on the most recent parablock ancestors** | Included in the latest relay parent | Included in a relay parent (not necessarily the latest), with augmented information from the latest ancestor in the [unincluded segment](#unincluded-segments) living in the parachain runtime |      Collators can start building parablocks in advance      |
| **Number of unincluded parablocks**                            |              Only one               |                                                                  One, or more than one (depends on configuration parameters)                                                                   |               More efficiency and scalability                |
| **Parablock generation can take up to**                        |             0.5 seconds             |                                                                                           2 seconds                                                                                            |                 4x more data in a parablock                  |
| **Unincluded parablocks**                                      |        Cannot be re-proposed        |                                                              Can be re-proposed if not successfully included in the first attempt                                                              |            Decrease wastage of unused blockspace             |

In synchronous backing collators generate parablocks using context entirely pulled from the relay
chain. While in asynchronous backing collators use additional context from the unincluded segment.
Parablocks are included every 6 seconds because backing of parablock `N + 1` and inclusion of
parablock `N` happen on the same relay chain bock ([pipelining](#pipelining)). Because the
throughput is increased by 2x and parachains have 4x more time to generate blocks, asynchronous
backing is expected to deliver 8x more blockspace to parachains.

### Sync Backing as special case of Async Backing

Two parameters of asynchronous backing can be controlled by
[Governance](./learn-polkadot-opengov.md):

- [`allowed_ancestry_len`](https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L54):
  the number of parachain blocks a collator can produce that are not yet included in the relay
  chain.
- [`max_candidate_depth`](https://github.com/paritytech/polkadot-sdk/blob/f204e3264f945c33b4cea18a49f7232c180b07c5/polkadot/primitives/src/vstaging/mod.rs#L49):
  the oldest relay chain parent a parachain block can be built on top of.

Values of zero for both correspond to synchronous backing: `allowed_ancestry_len = 0` means there
can be only one unincluded parablock at all times, `max_candidate_depth = 0` means a parablock can
be built only on the latest relay parent for that parachain.

### Async Backing Diagram

The diagram below shows the pipelining table for asynchronous backing. The diagram assumes:

- `allowed_ancestry_len = 1`, meaning that there can be a maximum of two unincluded parablocks at
  all times
- `max_candidate_depth = 1`, meaning parablocks can be anchored to the last or second-last relay
  parent

![async-backing](../assets/async-backing.png)

From left to right, parablock P1 is backed into the relay chain block R1 and included into R2. While
P1 undergoes backing, collators can already start to generate P2, which will have R0 as a relay
parent (showed with an `x`). In this way, P2 can be backed in R2 (the same relay block where P1 is
included) and included in R3. Moreover, collators can now use up to two seconds to generate
parablocks (tick mark `|` on the horizontal line after the `x` shows the deadline for parablock
generation). And so on, P3 can be generated while P2 is checked by backing groups, and P4 can be
built while P3 undergoing backing. In 24 seconds, P1 to P4 are included into the relay chain.

Note how at each inclusion event there are always two unincluded parablocks, i.e. compared to
synchronous backing there can be multiple unincluded parablocks (i.e. [pipelining](#pipelining)).
For example, when P1 is included, P2 and P3 are not included yet. Collators were able to generate
multiple unincluded parablocks because on their end they have the
[unincluded segment](#unincluded-segments), a local storage of not included parablocks. Collating on
top of unincluded parents means the only time limit to generate a parablock is how long it takes to
back it (2s). The 6s relay chain block delay includes this backing execution timeout (2s) and some
time for network latency (time it takes to gossip messages across the entire network). Thus, even if
a collator has >2 seconds to produce a block, the validators will still have less than 6 seconds (~2
seconds) to check it.

## Terminology

### Candidate Receipt

Saying that a parablock has been included in a realy chain parent does not mean that the entire
parablock is in the relay chain block. Instead, **candidate receipt** consisting of the hash of the
parablock, state roots and ID info is placed on the parent block on the relay chain. The relay chain
does not access the entire state of a parachain but only the values that changed during that block
and the merkelized hashes of the unchanged values.

### Pipelining

Asynchronous backing is a feature that introduces
[pipelining](https://www.techtarget.com/whatis/definition/pipelining) to the parachain block
[generation, backing and inclusion](./learn-parachains-protocol.md). It is analogous to the logical
pipelining of processor instruction in "traditional" architectures, where some instructions may be
executed before others are complete. Instructions may also be executed in parallel, enabling
multiple processor parts to work on potentially different instructions simultaneously.

Bundles of state transitions represented as blocks may be processed similarly. In the context of
{{ polkadot: Polkadot :polkadot }}{{ kusama: Kusama :kusama }}, pipelining aims to increase the
throughput of the entire network by completing the backing and inclusion steps for different blocks
at the same time. Asynchronous backing does not just allow for pipelining within a single pipe (or
core). It lays the foundation for a large number of pipes (~10 cores) to run for the same parachain
at the same time. In that way we have two distinct new forms of parallel computation: having one
block backed and one included simultaneously using one core, and having having `n` blocks backed and
`n` blocks included simultaneously using `n` cores.

### Unincluded Segments

Unincluded segments are chains of candidate parablocks that have yet to be included in the relay
chain, i.e. they can contain parablocks at any stage pre-inclusion. An unincluded segment may thus
include candidates that are seconded, backable, or backed. Every parablock candidate recorded in the
unincluded segment is immediately advertised to validators to begin the backing process.

The backing process occurs on the relay chain, whereas unincluded segments live in the runtimes of
parachain collators. The core functionality that asynchronous backing brings is the ability to build
on these unincluded segments of block ancestors rather than building only on ancestors included in
the relay chain state.

The purpose of each unincluded segment is two fold:

- Make each parachain aware of when and at what depth it can build blocks that won't be rejected by
  the relay chain
- Provide critical context necessary to build parablocks with parent blocks that have yet to be
  included. The unincluded segment is all about building parablocks.

### Prospective Parachains

The purpose of
[prospective parachains](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html)
is two fold:

- Keep track of parablocks which have been submitted to backers but not yet included. This includes
  tracking the full unincluded ancestry of each parablock, without which it wouldn't be possible to
  verify their legitimacy.

- Look up and provide candidates which are children of the most recently included parablock for each
  parachain. These are taken as inputs to the availability process. Prospective parachains is all
  about tracking, storing, and providing candidates to the availability/inclusion step.

Prospective parachains essentially repeats the work each [unincluded segment](#unincluded-segments)
does in tracking candidates. Validators cannot simply trust the availability or validity of records
kept on parachains. Prospective parachains is the relay chain's record of all parablock candidates
undergoing the backing and inclusion process. It is the authoritative gate keeper for parablock
validity. Whereas the unincluded segment is a local record which allows parachains to produce blocks
which comply with the rules prospective parachains later enforces.

The unincluded segment lives in the parachain runtime, so it doesn't know or care about forks/other
parachains. Prospective parachains lives in the relay chain client. So it has to simultaneously keep
track of candidates from all forks of all parachains. It is as if you folded the unincluded segments
from every fork of every parachain into one giant data structure. When you fold unincluded segments
representing different chain forks together, they create a tree structure. Hence the term
[**fragment tree**](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html#fragment-trees).

A single unincluded segment tells a collator whether it can build on top of one fork of one
parachain. Prospective parachains tells a validator whether it should accept blocks built on top of
any fork from any parachain.

A parablock stops being a prospective parablock at the moment when it is included on chain. At that
point prospective parachains doesn't have to care about it anymore. Alternatively, a parablock's
relay parent can get too old before that parablock is included, in which case prospective parachains
can throw away the candidate.

## Learn More

This topic is evolving and being implemented at the moment, keep up to date using the following
resources:

- [Polkadot Roadmap Roundup](https://polkadot.network/blog/polkadot-roadmap-roundup) - Article by
  Rob Habermeier, Polkadot founder, details the plans for Polkadot for 2023.
- [Asynchronous Backing Spec & Tracking Issue](https://github.com/paritytech/polkadot/issues/3779) -
  The implementation tracking issue for asynchronous backing
- [Prospective Parachains Subsystem - The Polkadot Parachain Host Implementers' Guide](https://paritytech.github.io/polkadot/book/node/backing/prospective-parachains.html)
- Chapter 6.11. from Polkadot Blockchain Academy (PBA) lecture material:
  [Asynchronous Backing (Shallow)](https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-shallow/page.html)
- Chapter 6.15. from PBA lecture material:
  [Asynchronous Backing (Deep)](https://polkadot-blockchain-academy.github.io/pba-book/polkadot/async-backing-deep/page.html)
- Polkadot Blog Post -
  [Asynchronous Backing: Elevating Polkadot's Performance and Scale](https://www.polkadot.network/blog/elevating-polkadots-performance-and-scale-with-asynchronous-backing)
