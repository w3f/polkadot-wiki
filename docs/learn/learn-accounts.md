---
id: learn-accounts
title: Polkadot Accounts
sidebar_label: Polkadot Accounts
description: An explanation of accounts, indices, identity, and reaping.
keywords: [account, polkadot account, polkadotjs, indices, identity, reaping]
slug: ../learn-accounts
---

import RPC from "./../../components/RPC-Connection";

This document covers the basics of Polkadot and Kusama account addresses and how they exist
on-chain. For a more in-depth explanation of the cryptography behind them, please see
[the cryptography page](learn-cryptography.md).

## Address Format

The address format used in Substrate-based chains is SS58. SS58 is a modification of Base-58-check
from Bitcoin with some minor changes. Notably, the format contains an _address type_ prefix that
identifies an address as belonging to a specific network.

For example:

- Polkadot addresses **always start with** the number **1**.
- Kusama addresses always start with a capital letter, such as **C D, F, G, H, J**.
- Generic Substrate addresses **always start with** the number **5**.

These prefixes, including how to validate addresses, are embedded in the Substrate SS58 format.
Never use regular expressions for address validation.

It's important to understand that different network formats are **merely other representations of
the same public key in a private-public keypair** generated by an address generation tool. As a
result, the addresses across Substrate-based chains are compatible as long as the format is
converted correctly.

As of Runtime 28, the default [address format](learn-accounts.md##address-format) is the
[`MultiAddress`](https://github.com/paritytech/substrate/blob/master/primitives/runtime/src/multiaddress.rs)
type.

This `enum` is a multi-format address wrapper for on-chain accounts and allows us to describe
Polkadot's default address format to represent many different address types. This includes **20
byte**, **32 byte**, and **arbitrary raw byte** variants. It also allows an enhancement to the
original [`indices`](learn-accounts.md#indices) lookup.

:::info

Many wallets allow you to convert between formats. Stand-alone tools exist as well; you can find
them in the [address conversion tools](#address-conversion-tools) section.

:::

## Address Generation, Derivation, and Portability

A valid account requires a private key that can sign on to one of the
[supported curves and signature schemes](../build/build-protocol-info.md#cryptography).

Most wallets take many steps from a mnemonic phrase to an account key, which affects the ability to
use the same mnemonic phrase in multiple wallets. Wallets that use different measures will arrive at
a different set of addresses from the exact mnemonic phrase.

### Seed Generation

Most wallets generate a mnemonic phrase for users to back up their wallets and generate a private
key from the mnemonic. Not all wallets use the same algorithm to convert from mnemonic phrase to
private key.

A typical mnemonic phrase generated by
[the Subkey tool](https://docs.substrate.io/reference/command-line-tools/subkey/) is shown below.

```
'caution juice atom organ advance problem want pledge someone senior holiday very'
```

Its corresponding _private/public keypair_ is also shown.

```
Secret seed (Private key): 0x056a6a4e203766ffbea3146967ef25e9daf677b14dc6f6ed8919b1983c9bebbc
Public key (SS58): 5F3sa2TJAWMqDhXG6jhV4N8ko9SxwGy8TpaNS1repo5EYjQX
```

Subkey and Polkadot-JS based wallets use the BIP39 dictionary for mnemonic generation, but use the
entropy byte array to generate the private key, while full BIP39 wallets (like Ledger) use 2048
rounds of PBKDF2 on the mnemonic. The same mnemonic may generate different private keys on other
wallets due to the various cryptographic algorithms used.

See [Substrate BIP39 Repo](https://github.com/paritytech/substrate-bip39) for more information.

## Obtaining and Managing an Address

The **most user-friendly** way to create a Polkadot or Kusama address is through the
[Polkadot-JS UI](https://polkadot.js.org/apps/#/accounts). Remember to back up the seed phrase used
to generate your account - the accounts are stored only in your browser, so purging the cache will
wipe your accounts as well. You would then have to recreate them using the seed phrase given to you
by the UI - this will also restore all your previously held balances.

A **more convenient and recommended** method of keeping the accounts stored on your computer is
using the [Polkadot{.js} extension](https://github.com/polkadot-js/extension). This extension
remembers your accounts and allows you to clear your browser cache without fear. Still, don't forget
to back up your seed phrase - if you lose access to this computer or the extension somehow crashes
beyond repair, the phrase will come in handy.

Please note that as this keeps your accounts in the browser, it is not safe to keep significant
holdings. By definition, a browser is a "hot wallet" and susceptible to a wide range of attacks, so
keep your funds in cold storage when dealing with non-trivial amounts. For improved security, you
can securely stash away the seed phrase for your accounts and remove all traces of the accounts from
your computer after creating them.

Besides the extension and the default UI, Polkadot and Kusama addresses can also be created with the
[Subkey tool](https://github.com/paritytech/substrate/tree/master/bin/utils/subkey). Subkey is
intended for users comfortable with using the command line and can seem intimidating but is quite
approachable. Follow the instructions in the
[Subkey documentation](https://docs.substrate.io/reference/command-line-tools/subkey/). When used
properly, Subkey is the **most secure** available method of creating an account.

There is also the very secure [Parity Signer](https://www.parity.io/signer/). This keeps your keys
on an air-gapped mobile phone. However, it does require obtaining an old Android or iOS-compatible
phone that you are comfortable using only for Parity Signer.

Hardware wallet integration is possible with Ledger. A full guide is available
[here](../general/ledger.md).

Alternatively, you might find other wallets on the [Wallet](../build/build-wallets.md) page, but
bear in mind that some of these are **unaudited** and are not officially affiliated with Web3
Foundation or the Polkadot project unless otherwise stated.

## Balance Types

On Polkadot, **four different balance types** indicate whether your balance can be used for
transfers, to pay fees, or must remain frozen and unused due to an on-chain requirement.

The `AccountData` struct defines the balance types in Substrate. The four types of balances include
`free`, `reserved`, `misc_frozen` (`miscFrozen` in camel-case), and `fee_frozen` (`feeFrozen` in
camel-case).

In general, the **usable** balance of the account is the amount that is `free` minus any funds that
are considered frozen (either `misc_frozen` or `fee_frozen`) and depend on the reason for which the
funds are to be used. If the funds are to be used for transfers, then the usable amount is the
_free_ amount minus any `misc_frozen` funds. However, if the funds are to be used to pay transaction
fees, the usable amount would be the _free_ funds minus `fee_frozen`.

The **total** balance of the account is considered to be the sum of `free` and `reserved` funds in
the account. Reserved funds are held due to on-chain requirements and can usually be freed by taking
some on-chain action. For example, the "Identity" pallet reserves funds while an on-chain identity
is registered, but by clearing the identity, you can unreserve the funds and make them free again.

## Existential Deposit and Reaping

When you generate an account (address), you only generate a _key_ that lets you access it. The
account does not exist yet on-chain. For that, it needs the existential deposit: 0.0000333333 KSM
(on Kusama) or 1 DOT (on Polkadot mainnet).

Having an account go below the existential deposit causes that account to be _reaped_. The account
will be wiped from the blockchain's state to conserve space, along with any funds in that address.
You do not lose access to the reaped address - as long as you have your private key or recovery
phrase, you can still use the address - but it needs a top-up of another existential deposit to be
able to interact with the chain.

Transaction fees cannot cause an account to be reaped. Since fees are deducted from the account
before any other transaction logic, accounts with balances _equal to_ the existential deposit cannot
construct a valid transaction. Additional funds will need to be added to cover the transaction fees.

Here's another way to think about existential deposits. Ever notice those `Thumbs.db` files on
Windows or `.DS_Store` files on Mac? Those are junk; they serve no specific purpose other than
making previews a bit faster. If a folder is empty saved for such a file, you can remove the folder
to clear the junk off your hard drive. That does not mean you lose access to this folder forever -
you can always recreate it. You have the _key_, after all - you're the computer's owner. It just
means you want to keep your computer clean until you maybe end up needing this folder again and then
recreate it. Your address is like this folder - it gets removed from the chain when nothing is in it
but gets put back when it has the existential deposit.

## Indices

A Kusama or Polkadot address can have an index. An index is like a short and easy-to-remember
version of an address. Claiming an index requires a deposit that is released when the index is
cleared. Any index can be claimed as long as it is not taken by someone else.

But what if an account gets reaped as explained above? In that case, the index is emptied. In other
words, the slot frees up again, making it available for anyone to claim it. It is possible to
_freeze_ an index and permanently assign it to an address. This action consumes a deposit but makes
sure that the index can never be reclaimed unless released by the holding account.

:::note Lookup Account Index on-chain

When someone shares their account index, their actual account address on-chain can be looked up
through Polkadot-JS Apps UI > Developer > Chain state > Storage and selecting state query on indices
pallet for the account corresponding to the index.

:::

Here is an example snapshot that shows how to lookup the corresponding account address of the
account index 1988 on
[Westend network (Polkadot Test Network)](../maintain/maintain-networks.md#westend-test-network),
using Polkadot-JS Apps UI. The output shows the account address, its deposit amount and a boolean
flag which indicates whether this is claimed permanently.

![query account index](../assets/accounts/query-index.png)

To register an index, submit a `claim` extrinsic to the `indices` pallet, and follow up with a
`freeze` extrinsic. The easiest way to do this is via PolkadotJS UI through the _Developer ->
Extrinsics_ menu:

![Indices extrinsics](../assets/accounts/index.png)

To find available indices to claim on Polkadot or Kusama,
[this helper tool may come in handy](https://www.shawntabrizi.com/substrate-js-utilities/indices/).

## Identities

The [_Identities pallet_](https://github.com/paritytech/substrate/tree/master/frame/identity) built
into Polkadot allows users to attach on-chain metadata to their accounts. Independent registrars can
verify this metadata to provide trustworthiness. To learn more about how to set or release an
identity, how to define sub-accounts, or how to become a registrar, please read
[this guide](learn-identity.md).

## Proxy Accounts

Polkadot comes with a generalized proxy account system that allows users to keep keys in cold
storage while proxies act on their behalf with restricted (or unrestricted) functionality. See the
[proxies](learn-proxies.md) page for more information.

## Multi-signature Accounts

It is possible to create a multi-signature account in Substrate-based chains. A multi-signature
account is composed of one or more addresses and a threshold. The threshold defines how many
signatories (participating addresses) need to agree on submitting an extrinsic for the call to be
successful.

For example, Alice, Bob, and Charlie set up a multi-sig with a threshold of 2. This means Alice and
Bob can execute any call even if Charlie disagrees with it. Likewise, Charlie and Bob can execute
any call without Alice. A threshold is typically a number smaller than the total number of members
but can also be equal to it, which means they all have to agree.

:::note Explainer on multisig accounts

Learn more about multisig accounts from our
[technical explainer video](https://www.youtube.com/watch?v=ZJLqszvhMyM&list=PLOyWqupZ-WGuAuS00rK-pebTMAOxW41W8&index=25&ab_channel=Polkadot).

:::

Multi-signature accounts have several uses:

- securing your own stash: use additional signatories as a 2FA mechanism to secure your funds. One
  signer can be on one computer, and another can be on another or in cold storage. This slows down
  your interactions with the chain but is orders of magnitude more secure.
- board decisions: legal entities such as businesses and foundations use multi-sigs to govern over
  the entity's treasury collectively.
- group participation in governance: a multi-sig account can do everything a regular account can. A
  multi-sig account could be a council member in Kusama's governance, where a set of community
  members could vote as one entity.

Multi-signature accounts **cannot be modified after being created**. Changing the set of members or
altering the threshold is not possible and instead requires the dissolution of the current multi-sig
and creation of a new one. As such, multi-sig account addresses are **deterministic**, i.e. you can
always calculate the address of a multi-sig by knowing the members and the threshold, without the
account existing yet. This means one can send tokens to an address that does not exist yet, and if
the entities designated as the recipients come together in a new multi-sig under a matching
threshold, they will immediately have access to these tokens.

### Generating Addresses of Multi-signature Accounts

:::note Addresses that are provided to the multi-sig wallets must be sorted

The below methods for generating sort the accounts for you, but if you are implementing your own
sorting, then be aware that the public keys are compared byte-for-byte and sorted ascending before
being inserted in the payload that is hashed.

:::

Addresses are deterministically generated from the signers and threshold of the multisig wallet. For
a code example (in TypeScript) of generating you can view the internals of `@w3f/msig-util`
[here](https://github.com/lsaether/msig-util/blob/master/src/actions/deriveAddress.ts).

The `@w3f/msig-util` is a small CLI tool that can determine the multi-signature address based on
your inputs.

```zsh
$ npx @w3f/msig-util@1.0.7 derive --addresses 15o5762QE4UPrUaYcM83HERK7Wzbmgcsxa93NJjkHGH1unvr,1TMxLj56NtRg3scE7rRo8H9GZJMFXdsJk1GyxCuTRAxTTzU --threshold 1
npx: installed 79 in 7.764s
--------------------------------
Addresses: 15o5762QE4UPrUaYcM83HERK7Wzbmgcsxa93NJjkHGH1unvr 1TMxLj56NtRg3scE7rRo8H9GZJMFXdsJk1GyxCuTRAxTTzU
Threshold: 1
Multisig Address (SS58: 0): 15FKUKXC6kwaXxJ1tXNywmFy4ZY6FoDFCnU3fMbibFdeqwGw
--------------------------------
```

The Polkadot-JS Apps UI also supports multi-sig accounts, as documented in the
[Account Generation page](learn-account-generation.md#multi-signature-accounts). This is easier than
generating them manually.

### Making Transactions with a Multi-signature Account

There are three types of actions you can take with a multi-sig account:

- Executing a call `as_multi`.
- Approving a call `approve_as_multi`.
- Cancelling a call `cancel_as_multi`.

In scenarios where only a single approval is needed, a convenience method `as_multi_threshold_1`
should be used. This function takes only the other signatories and the raw call as its arguments.

However, in anything but the simple one approval case, you will likely need more than one of the
signatories to approve the call before finally executing it. When you create a new call or approve a
call as a multi-sig, you will need to place a small deposit. The deposit stays locked in the pallet
until the call is executed. The deposit is to establish an economic cost on the storage space that
the multi-sig call takes up on the chain and discourage users from creating dangling multi-sig
operations that never get executed. The deposit will be reserved in the caller's accounts, so
participants in multi-signature wallets should have spare funds available.

The deposit is dependent on the `threshold` parameter and is calculated as follows:

```
Deposit = DepositBase + threshold * DepositFactor
```

Where `DepositBase` and `DepositFactor` are chain constants set in the runtime code.

Currently, the **DepositBase** equals `deposit(1, 88)` (key size is 32; value is size 4+4+16+32 = 56
bytes) and the **DepositFactor** equals `deposit(0, 32)` (additional address of 32 bytes).

The deposit function in JavaScript is defined below, cribbed from the
[Rust source](https://github.com/paritytech/polkadot/blob/master/runtime/polkadot/constants/src/lib.rs).

```js
// Polkadot
const DOLLARS = 10000000000; // planck
const MILLICENTS = 100000; // planck

// Kusama
// const DOLLARS = 166666666666.67;
// const MILLICENTS = 1666666.66;

const deposit = (items, bytes) => {
  return items * 20 * DOLLARS + bytes * 100 * MILLICENTS;
};

console.log("DepositBase", deposit(1, 88));
console.log("DepositFactor", deposit(0, 32));
```

Thus the deposit values can be calculated as shown in the table below. They are also shown
in [plancks](learn-DOT.md#polkadot) for convenience.

|          | Deposit Base                                                                                                    | Deposit Factor                                                                                                  |
| -------- | --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------- |
| Polkadot | <RPC network="polkadot" path="consts.multisig.depositBase" defaultValue={200880000000} filter="humanReadable"/> (<RPC network="polkadot" path="consts.multisig.depositBase" defaultValue={200880000000}/> Planck) | <RPC network="polkadot" path="consts.multisig.depositFactor" defaultValue={320000000 } filter="humanReadable"/> (<RPC network="polkadot" path="consts.multisig.depositFactor" defaultValue={320000000 }/> Planck) |
| Kusama   | <RPC network="kusama" path="consts.multisig.depositBase" defaultValue={66959996400} filter="humanReadable"/> (<RPC network="kusama" path="consts.multisig.depositBase" defaultValue={66959996400}/> Planck)    | <RPC network="kusama" path="consts.multisig.depositFactor" defaultValue={106665600} filter="humanReadable"/> (<RPC network="kusama" path="consts.multisig.depositFactor" defaultValue={106665600}/> Planck)   |

Let's consider an example of a multi-sig on Polkadot with a threshold of 2 and 3 signers: Alice,
Bob, and Charlie. First, Alice will create the call on-chain by calling `as_multi` with the raw
call. When doing this Alice will have to deposit `DepositBase + (2 * DepositFactor) = 20.152 DOT`
while she waits for either Bob or Charlie also to approve the call using the `approve_as_multi`
extrinsic. When Bob comes to approve the call and execute the transaction, he will not need to place
the deposit, and Alice will receive her deposit back. Similarly, after Alice sends the initial
transaction, say Bob or Charlie choose to cancel the transaction due to an error on Alice's part,
they can use the `cancel_as_multi` extrinsic. The cancellation will release the deposit back to
Alice.

### Example with Polkadot JS

:::info

Check the "How to create a multisig account" section on
[this support page](https://support.polkadot.network/support/solutions/articles/65000181826-how-to-create-and-use-a-multisig-account).
We recommend trying out the tutorial on
[Westend network](../maintain/maintain-networks.md#westend-test-network) - Polkadot's testnet.

:::

## Decoding Call Data

:::info

Check the "How to use a multisig account" section on
[this support page](https://support.polkadot.network/support/solutions/articles/65000181826-how-to-create-and-use-a-multisig-account).

:::

## Resources

- [Understanding Accounts and Keys in Polkadot](https://www.crowdcast.io/e/polkadot-keys) - An
  explanation of what the different kinds of accounts and keys are used for in Polkadot, with Bill
  Laboon and Chinmay Patel of BlockX Labs.
