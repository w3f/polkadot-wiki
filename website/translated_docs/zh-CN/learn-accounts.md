---
id: learn-accounts
title: Polkadot 账户
sidebar_label: Polkadot 账户
description: 账户、账户索引、账户身份和回收机制的解释
---

本文档涵盖 Polkadot 和 Kusama 账户的基本地址及其在链上的保存。 欲了解更多关于加密技术背后的详细解释，请参阅 [加密页面](learn-cryptography)。

## 地址格式

基于 Substrate 的链的地址格式是SS58。SS58 是一种对于比特币的 Base-58-Check 进行小幅修改的格式。需要注意，此格式包含_地址类型_前缀，可以识别地址具体属于哪一个网络。

例如:

- Polkadot 地址总是以数字1开头。
- Kusama 地址总是以大写字母开头，如C、D、F、G、H、J...
- 通用Substrate 地址以5开头。

这些前缀在[此处](https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58))定义。

It's important to understand that the different formats for different networks are **merely different representations of the same public key in a private-public keypair** generated by an address generation tool. This makes the addresses compatible across Substrate-based chains as long as you convert the format.

> Many wallets allow you to convert between formats. Stand-alone tools exist as well, you can find them in the [address coversion tools](#address-conversion-tools) section.

## 地址的生成，派生和迁移

一个有效的账户只需要一个可以在[supported curves and signature scheme](build-protocol-info#cryptography)签名的私钥。多数钱包然间从助记词到生成账户需要经由许多步骤。同一组助记词，不同钱包采用不同步骤生成的账户也不会相同。

### 助记词(种子) 生成

Most wallets generate a mnemonic phrase for users to back up their wallets and generate a private key from the mnemonic. Not all wallets use the same algorithm to convert from mnemonic phrase to private key.

基于 Subkey 和 Polkadot-JS 的钱包采用BIP39词典来生成助记词，使用熵字节数组来生成私钥，这有别于其他 BIP39 钱包软件(如Ledger)采用 PBKDF2。所以，同一组助记词在经由这两种算法后并不能产生同样的私钥。更多相关细节请参阅[Substrate BIP39](https://github.com/paritytech/substrate-bip39)

### 衍生路径

许多 Polkadot 密钥生成工具支持硬派和软派生。更多关于派生路径的细节和例子请参考 [Subkey 文档](https://substrate. dev/docs/en/knowledgebase/integrate/subkey) 。Polkadot-JS 的应用和拓展同 Parity Signer 也支持采用和 Subkey 相同语法的自定义派生路径。

一些钱包会自动将派生路径添加到生成的助记词短语的末尾。这将为单独的路径生成单独的种子，从而允许使用相同的助记符，例如`<mnemonic phrase>//Polkadot` 和 `<mnemonic phrase>//Kusama`。尽管您可以正确保存助记词短语，但除非在两个钱包中使用相同的派生路径，否则在另一个钱包中使用它将不会生成相同的地址。

Polkadot 和 Kusama 都在[BIP44注册表](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)中注册了路径。

> **Warning:** You must have both the parent private key as well as the derivation path to arrive at the key for an address. Do not use custom derivation paths unless you are comfortable with your understanding of this topic.

### 可移植性

以上信息为我们带来了可移植性：在多个钱包中使用助记词或种子的能力。可移植性取决于许多因素：

- 派生路径
- 助记符格式
- 种子衍生
- 签名方案

如果要在多个钱包中使用相同的助记符，请确保它们遵循兼容生成密钥和签名消息的方法。如果找不到可理解的文档，请与项目维护人员联系。

|                  | 助记符格式  |     派生路径      |     种子衍生      |            签名支持             |
|:---------------- |:------:|:-------------:|:-------------:|:---------------------------:|
| Polkadot{.js} 扩展 |   标准   |     用户自定义     |     BIP32     |           sr25519           |
| Polkadot-JS 应用程序 | 标准\* |     用户自定义     |     BIP32     | sr25519, ed25519, secp256k  |
| 账本               | BIP39  | BIP44&dagger; | BIP32&Dagger; |        ed25519&sect;        |
| Subkey           | 标准\* |     用户自定义     |     BIP32     | sr25519, ed25519, secp256k1 |

\ * 附带 BIP39 的 Ed25519 密钥具有[有限的兼容性](https://github.com/paritytech/substrate-bip39)。

&dagger; [BIP44 注册表](https://github.com/satoshilabs/slips/blob/master/slip-0044.md)

&Dagger; 基于[Khovratovich](https://github.com/LedgerHQ/orakolo/blob/master/papers/Ed25519_BIP%20Final.pdf)的 Ed25519 和 BIP32

&sect; Sr25519 计划

### 好奇：前缀的工作原理

这是[ SS58 文档](https://github.com/paritytech/substrate/wiki/External-Address-Format-(SS58))的申明：

- Polkadot 的地址类型为`000000000`，所以`0`是十进制。
- Kusama (Polkadot 金丝雀) 的地址类型为`00000010b`，因此`2`以十进制表示。
- 通用 Substrate 的地址类型为`00101010b`，十进制为`42`。

因为 Base58-check 字母没有数字0，所以最小值确实是1。因此，`00000000b`在 Base58 中是1。如果我们尝试[解码](https://www.better-converter.com/Encoders-Decoders/Base58Check-to-Hexadecimal-Decoder)诸如` 1FRMM8PEiWXYax7rpS6X4XZX1aAAxSWx1CrKTyrVYhV24fg `的Polkadot地址，则结果为` 000aff6865635ae11013a83835c019d44ec3f865145943f487ae82a8b7e7bed`。第一个字节是`00`，实际上既是二进制的`00000000`又是十进制的`0`，因此它与 Polkadot 的地址类型匹配。

让我们看一下 Substrate 的地址。如果我们解码` 5CK8D1sKNwF473wbuBP6NuhQfPaWUetNsWUNAAzVwTfxqjfr`，则会得到` 2a0aff6865635ae11013a83835c019d44ec3f865145943f487ae82a8e7bed3a66b77e5`。第一个字节是`2a`，当[从十六进制转换为十进制](https://www.rapidtables.com/convert/number/hex-to-decimal.html)时是42。42的二进制是`00101010`，就像 SS58 文档所述的那样。

最后，让我们看一下 Kusama 的地址。解码` CpjsLDC1JFyrhm3ftC9Gs4QoyrkHKhZKtK7YqGTRFtTafgp`会让我们得到` 020aff6865635ae11013a83835c019d44ec3f865145943f487ae82a8e7bed3a66b0985`，正如被指定的那样，其中第一个字节为`02`。如果我们尝试以完全不同的字母，例如` J4iggBtsWsb61RemU2TDWDXTNHqHNfBSAkGvVZBtn1AJV1a`，我们仍然将`02`作为第一个字节：` 02f2d606a67f58fa0b3ad2b556195a0ef905676efd4e2114`。从直觉上看，有些地址总是有相同的前缀，而其他一些地址像是用 Kusama 生成的却可能千差万别，但这只是对于 Base58-check 编码的怪癖。

## 获取和管理地址

The **most user-friendly** way to create a Polkadot or Kusama address is through the [Polkadot-JS UI](https://polkadot.js.org/apps/#/accounts). Remember to back up the seed phrase used to generate your account - the accounts are stored only in your browser, so purging the cache will wipe your accounts as well. You would then have to recreate them using the seed phrase given to you by the UI - this will also restore all your previously held balances.

**更方便和推荐**的将帐户保存在计算机上方法是使用[ Polkadot {.js}扩展名](https://github.com/polkadot-js/extension)。此扩展程序可以记住您的帐户，让您不必担心即可清除浏览器缓存。不过，不要忘记备份您的种子短语 - 如果您无法使用这台计算机，或者扩展名以某种方式崩溃而无法修复，则该短语将派上用场。

请注意，由于这会将您的帐户保留在浏览器中，因此这里不是一个存放大量资产的安全之地。根据定义，浏览器是一个“热钱包”，容易受到各种各样的攻击，因此，在处理不重要的数额时，请将资金保存在冷库中。为了提高安全性，您可以安全地隐藏帐户的种子短语，并在创建帐户后从计算机中删除所有帐户痕迹。

除了扩展名和默认UI外，还可以使用[ 子键工具](https://github.com/paritytech/substrate/tree/master/bin/utils/subkey)。子键旨在供用户熟悉使用命令行使用，并且看起来令人生畏，但相当平易近人。请按照[子键文档](https://substrate.dev/docs/en/knowledgebase/integrate/subkey)。如果使用得当，子键是创建帐户的**最安全**的可用方法。

还有一个非常安全的[奇偶校验签名人](https://www.parity.io/signer/)。这样可以将您的钥匙保持在气密的手机上。但是，这确实需要获得您常用的且仅用于 Parity Signer 的旧 Android 或 iOS 兼容手机。

账本可以与硬件钱包集成。完整指南可在[此处](learn-ledger)获得。

另外，您可能会在[钱包](build-wallets)页面上找到其他钱包，但请记住，其中一些是**未经审计的**，除非另有说明，否则它们并不隶属于Web3 Foundation或Polkadot的正式项目。

## 余额类型

在 Polkadot 上，有四种不同的余额类型，提示您的余额是否可以用于转账，支付费用，或者由于链上要求而必须冻结且不被使用。

余额类型由 Substrate 中的`AccountData`结构定义。四种类型的余额包括`free`，`reserved`，`misc_frozen` (驼峰体为`miscFrozen`) 和` fee_frozen` (驼峰体为`feeFrozen`)。

通常，帐户的**可用**余额是`自由`的金额减去任何被视为冻结的资金 (`misc_frozen`或`free_frozen`) ，具体取决于使用资金的原因。如果资金将用于转账，则可用金额为“自由”金额减去任何`misc_frozen`资金。但是，如果要使用这些资金来支付交易费用，则可用金额将是“自由”资金减去`fee_frozen `的任何资金。

帐户的“总”余额被认为是帐户中“自由”资金的数量减去任何“保留”的资金。保留的资金是根据链上的要求持有的，通常可以通过执行一些链上操作来释放。例如，“身份”模块在注册链上身份时保留资金，但是通过清除身份，您可以取消保留资金并再次释放它们。

## 现有存款和回收

When you generate an account (address), you only generate a _key_ that lets you access it. The account does not exist yet on-chain. For that, it needs the existential deposit: 0.001666666667 KSM (on Kusama) or 1 DOT (on Polkadot mainnet).

如果帐户低于现有存款，则会导致该帐户_被回收_。该帐户以及该地址中的所有资金将从区块链状态中删除，以节省空间。您不会失去对回收地址的访问权限 - 只要您拥有私钥或恢复短语，您仍然可以使用该地址 - 但它需要充值额外的存续金额才能与链进行交互。

Transaction fees cannot cause an account to be reaped. Since fees are deducted from the account before any other transaction logic, accounts with balances _equal to_ the existential deposit cannot construct a valid transaction. Additional funds will need to be added to cover the transaction fees.

Here's another way to think about existential deposits. Ever notice those `Thumbs.db` files on Windows or `.DS_Store` files on Mac? Those are junk, they serve no specific purpose other than making previews a bit faster. If a folder is completely empty save for such a file, you can remove the folder to clear junk off your hard drive. That does not mean you lose access to this folder forever - you can always recreate it. You have the _key_, after all - you're the computer's owner. It just means you want to keep your computer clean until you maybe end up needing this folder again, and then recreate it. Your address is like this folder - it gets removed from the chain when nothing is in it, but gets put back when it has at least the existential deposit.

## 索引

A Kusama or Polkadot address can have an index. An index is like a short and easy to remember version of an address. Claiming an index requires a deposit which is released when the index is cleared.

Indices are populated in order. Think of them like slots going from 0 to any arbitrary number:

`[0][1][2][3][4][5][6]...`

If slots 0-2 are populated by addresses A, B and C respectively, and I add an existential deposit to address X, that address will automatically be put into slot 3. Henceforth, you can send me money by just sending to `[3]` rather than remembering my whole address.

```js
[0][1][2][3][4][5][6]...
[A][B][C][X][ ][ ][ ]...
```

But what if an account gets reaped as explained above? In that case, the index is emptied. In other words, the slot frees up again. If someone creates a new account, they may end up using the same index another address was using before.

It is possible to _freeze_ an index and permanently assign it to an address. This action consumes a deposit but makes sure that the index can never be reclaimed unless released by the holding account.

To register an index, submit a `claim` extrinsic to the `indices` pallet, and follow up with a `freeze` extrinsic. The easiest way to do this is via PolkadotJS UI through the _Developer -> Extrinsics_ menu:

![Indices extrinsics](assets/accounts/index.png)

To find available indices to claim, [this helper tool may come in handy](https://www.shawntabrizi.com/substrate-js-utilities/indices/).

## 身份

The [_Identities pallet_](https://github.com/paritytech/substrate/tree/master/frame/identity) built into Polkadot allows users to attach on-chain metadata to their accounts. This metadata can be verified by independent registrars to provide trustworthiness. To learn more about how to set or release an identity, how to define sub-accounts, or how to become a registrar, please read [this guide](learn-identity).

## 代理账户

Polkadot comes with a generalized proxy account system that allows users to keep keys in cold storage while proxies act on their behalf with restricted (or unrestricted) functionality. See the [proxies](learn-proxies) page for more information.

## 多签名账户

It is possible to create a multi-signature account in Substrate-based chains. A multi-signature account is composed of one or more addresses and a threshold. The threshold defines how many signatories (participating addresses) need to agree on the submission of an extrinsic in order for the call to be successful.

For example, Alice, Bob, and Charlie set up a multi-sig with a threshold of 2. This means Alice and Bob can execute any call even if Charlie disagrees with it. Likewise, Charlie and Bob can execute any call without Alice. A threshold is typically a number smaller than the total number of members but can also be equal to it, which means they all have to be in agreement.

> Learn more about multisig accounts from our [technical explainer video](https://www.youtube.com/watch?v=ZJLqszvhMyM&list=PLOyWqupZ-WGuAuS00rK-pebTMAOxW41W8&index=25&ab_channel=Polkadot).

Multi-signature accounts have several uses:

- 保护您自己的藏匿处：使用其他签署人作为2FA机制来保护您的资金。一个签名者可以在一台计算机上，另一个可以在另一台计算机上，或在冷库中。这减慢了您与链的交互速度，但是安全性提高了几个数量级。
- 董事会决策：诸如企业和基金会之类的法人实体使用多重签名来共同管理实体的国库。
- 团体参与治理：多签名帐户可以执行常规帐户可以执行的所有操作。具有多重签名的帐户可以是 Kusama 治理中的理事​​会成员，在该理事会中，一组社区成员可以作为一个实体进行投票。

Multi-signature accounts **cannot be modified after being created**. Changing the set of members or altering the threshold is not possible and instead requires the dissolution of the current multi-sig and creation of a new one. As such, multi-sig account addresses are **deterministic**, i.e. you can always calculate the address of a multi-sig just by knowing the members and the threshold, without the account existing yet. This means one can send tokens to an address that does not exist yet, and if the entities designated as the recipients come together in a new multi-sig under a matching threshold, they will immediately have access to these tokens.

### 生成多重签名帐户的地址

> NOTE: Addresses that are provided to the multi-sig wallets must be sorted. The below methods for generating sort the accounts for you, but if you are implementing your own sorting then be aware that the public keys are compared byte-for-byte and sorted ascending before being inserted in the payload that is hashed.

Addresses are deterministically generated from the signers and threshold of the multisig wallet. For a code example (in TypeScript) of generating you can view the internals of `@w3f/msig-util` [here](https://github.com/lsaether/msig-util/blob/master/src/actions/deriveAddress.ts).

The `@w3f/msig-util` is a small CLI tool that can determine the multisignature address based on your inputs.

```zsh
$ npx @w3f/msig-util@1.0.7 derive --addresses 15o5762QE4UPrUaYcM83HERK7Wzbmgcsxa93NJjkHGH1unvr,1TMxLj56NtRg3scE7rRo8H9GZJMFXdsJk1GyxCuTRAxTTzU --threshold 1
npx: installed 79 in 7.764s
--------------------------------
Addresses: 15o5762QE4UPrUaYcM83HERK7Wzbmgcsxa93NJjkHGH1unvr 1TMxLj56NtRg3scE7rRo8H9GZJMFXdsJk1GyxCuTRAxTTzU
Threshold: 1
Multisig Address (SS58: 0): 15FKUKXC6kwaXxJ1tXNywmFy4ZY6FoDFCnU3fMbibFdeqwGw
--------------------------------
```

The Polkadot-JS Apps UI also supports multi-sig accounts, as documented in the [Account Generation page](learn-account-generation#multi-signature-accounts). This is easier than generating them manually.

### 使用多重签名帐户进行交易

There are three types of actions you can take with a multi-sig account:

- 执行一笔交易
- 授权一笔交易
- 撤销一笔交易

In scenarios where only a single approval is needed, a convenience method `as_multi_threshold_1` should be used. This function takes only the other signatories and the raw call as its arguments.

However, in anything but the simple one approval case, you will likely need more than one of the signatories to approve the call before finally executing it. When you create a new call or approve a call as a multi-sig, you will need to place a small deposit. The deposit stays locked in the pallet until the call is executed. The reason for the deposit is to place an economic cost on the storage space that the multi-sig call takes up on the chain and discourage users from creating dangling multi-sig operations that never get executed. The deposit will be reserved in the caller's accounts so participants in multi-signature wallets should have spare funds available.

The deposit is dependent on the `threshold` parameter and is calculated as follows:

```
存款=存款基数+阈值*存款因子
```

Where `DepositBase` and `DepositFactor` are chain constants set in the runtime code.

Currently, the DepositBase is equal to `deposit(1, 88)` (key size is 32; value is size 4+4+16+32 = 56 bytes) and the DepositFactor is equal to `deposit(0,32)` (additional address of 32 bytes).

The deposit function in JavaScript is defined below, cribbed from the [Rust source](https://github.com/paritytech/polkadot/blob/master/runtime/polkadot/src/constants.rs#L26).

```js
// Polkadot
const DOLLARS = 10000000000; // planck
const MILLICENTS = 100000; // planck

// Kusama
// const DOLLARS = 166666666666.67;
// const MILLICENTS = 1666666.66;

const deposit = (items, bytes) => {
  return items * 20 * DOLLARS + bytes * 100 * MILLICENTS;
};

console.log("DepositBase", deposit(1, 88));
console.log("DepositFactor", deposit(0, 32));
```

Thus the deposit values can be calculated as shown in the table below.

|      | Polkadot (DOT) | Kusama (KSM)   | Polkadot (planck) | Kusama (planck) |
| ---- | -------------- | -------------- | ----------------- | --------------- |
| 存款基数 | 20.088         | 3.347999999942 | 200880000000      | 3347999999942   |
| 存款因子 | .032           | 0.005333333312 | 320000000         | 5333333312      |

Let's consider an example of a multi-sig on Polkadot with a threshold of 2 and 3 signers: Alice, Bob, and Charlie. First, Alice will create the call on chain by calling `as_multi` with the raw call. When doing this Alice will have to deposit `DepositBase + (2 * DepositFactor) = 20.152 DOT` while she waits for either Bob or Charlie to also approve the call. When Bob comes to approve the call and execute the transaction, he will not need to place the deposit and Alice will receive her deposit back.

### Example with Polkadot.JS

For this example, we will be using the [Westend](https://wiki.polkadot.network/docs/en/maintain-networks#westend-test-network) testnet and [Polkadot.JS Apps](https://wiki.polkadot.network/docs/en/learn-balance-transfers#polkadot-js-apps) to create a 2-of-3 multisig address and send a transaction with it.

> While Westend is meant to replicate the Polkadot mainnet as closely as possible, there are a few notable differences:
> 
> - Existential deposit is equal to 0.01 WND (Westies; Westend's native coin) instead of 1 DOT.
> - The multisignature transaction deposit is equal to ~1 WND instead of ~20.2 DOT.
> 
> The photos below reflects values in WND, but instructions are the same for DOT.

**To create a multisig address and send a transaction using it, you will need the following:**

- List of the multisig member's addresses. We will use Alice, Bob, and Charlie.
- DOT to deposit into the multisig address.
- ~20.2 DOT refundable deposit to send a multisig tarnsaction. This needs to be in the address that initiates a multisignature transaction (in this example, Alice).

You should already have your own account with some coins in it.

![Account page](assets/accounts/multisig-addy.png)

To generate the multisig address, we need to **add the multisig member addresses to the contact book** under "Accounts > Address book".

![Address book](assets/accounts/multisig-1.png)

For each address, click "Add contact" in the upper right and provide the address and a name.

![Add Contact](assets/accounts/multisig-2.png)

Here, Bob and Charlie have been added.

![Address books 2](assets/accounts/multisig-3.png)

**Next, we need to create the new multisignature address.** Navitage to the Accounts page (from the toolbar, "Accounts > Accounts") and click the "+ Multisig" button. We will supply the three multisig member addresses, with a value '2' for the threshold.

![New multisig](assets/accounts/multisig-4.png)

Click 'Create', and you should see the new multisig address appear on this Accounts page.

![5](assets/accounts/multisig-5.png)

**Let's fund the address now.** For this example, we will transfer some coins from Alice's account to the multisig address. Under Alice's address, click 'Send', select the multisig wallet as the destination, and provide an amount. Then, click 'Make Transfer', and then 'Sign and Submit'.

![6](assets/accounts/multisig-6.png) ![7](assets/accounts/multisig-7.png)

We can see that the multisig account now has a balance.

![9](assets/accounts/multisig-9.png)

**To send a transaction, we need one of the members to initiate it.** Let's use Alice to initiate the transaction.

Make sure Alice has enough coins to cover the multisig transaction deposit and the transaction fees. Then, click 'Send' under the "Multisig Test Address", select a destination address (we generated an address locally) and a transfer amount, and click 'Make Transfer'.

![10](assets/accounts/multisig-10.png)

To sign as Alice, make sure she is selected as the 'multisig signatory', click 'Sign and Submit', and sign the transaction.

![11](assets/accounts/multisig-11.png)

You will now see a pending transaction the 'Multisig Test Address' (the red '1' icon), and if you click the dropdown under Alice's balance, you will see that a value equivalent to the multisig deposit has been 'reserved', rendering that value untransferable until the multisig transaction completes.

![12](assets/accounts/multisig-12.png)

**Next, we need a second signature.** Let's get it from Bob. In Bob's browser, repeat the following from the above steps.

1. Add Alice, Charlie, and the multisig transaction destination addresses to Bob's Address book.
2. Create a new multisig address with the same parameters (Bob, Alice, and Charlie's addresses, and a threshold value of '2').

> NOTE: Since multisig address genereation is deterministic, if Bob (or any other member), on his computer, were to generate a multisig address using Alice's, Charlie's and his addresses, with a threshold value of '2', he would produce the **same** multisig address that Alice has here.

If done correctly, we should see that the **same** multisig address is produced in Bob's browser, and that a pending transaction is displayed, too.

![13](assets/accounts/multisig-13.png)

Next, to get Bob's signature, he needs to craft the same multisig transaction that Alice did by providing the same destination address and transfer amount (together, transaction parameters), signing, and submitting it. Alice initiated the transaction by uploading a signature of the hash of the transaction and the hash. These transaction parameters will allow Bob to produce and sign the same transaction (the same hash) that Alice signed earlier.

![14](assets/accounts/multisig-14.png)

Click 'Make Transfer', ensure that Bob is the 'multisig signatory', and click 'Sign and Submit'. Note that 'Multisig message with call (for final approval)' is automatically enabled; this means that, since the transaction will reached the signature threshold, it will execute the actual transaction on chain after adding the second signature.

![15](assets/accounts/multisig-15.png)

Assuming no errors, 'Multisig Destination Account' has a balance of 0.3 WND, and Alice's account has released the multisig transaction deposit.

![16](assets/accounts/multisig-16.png)

## Address Conversion Tools

You can use the tool below to convert any SS58 address for any network for use on different networks.

<div class="address-changer">
  <input class="address-changer-input" id="input" placeholder="贴下你的地址" oninput="globalThis.addressChanger()" />
  <select class="address-changer-select" id="prefix-select" oninput="globalThis.addressChanger()">
    <option value="0">Polkadot</option>
    <option value="2">Kusama</option>
    <option value="5">Plasm</option>
    <option value="10">Acala</option>
    <option value="16">Kulupu</option>
    <option value="28">Subsocial</option>
    <option value="36">Centrifuge</option>
    <option value="42">Substrate</option>
  </select>
  <span class="address-changer-output" id="output" />
</div>

Alternatively, use [this handy subscan tool](https://polkadot.subscan.io/tools/ss58_transform) or [this simple address address convertor](https://polkadot-address-convertor.netlify.app/).

## 资源

- [Understanding Accounts and Keys in Polkadot](https://www.crowdcast.io/e/polkadot-keys) - An explanation of what the different kinds of accounts and keys are used for in Polkadot, with Bill Laboon and Chinmay Patel of BlockX Labs.
