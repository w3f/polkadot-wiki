"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9349],{97771:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"learn/learn-safrole","title":"Polkadot Block Production: SAFROLE","description":"The Consensus Mechanism of Polkadot.","source":"@site/../docs/learn/learn-safrole.md","sourceDirName":"learn","slug":"/learn-safrole","permalink":"/docs/learn-safrole","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-safrole.md","tags":[],"version":"current","lastUpdatedBy":"bader y","lastUpdatedAt":1719324390000,"frontMatter":{"id":"learn-safrole","title":"Polkadot Block Production: SAFROLE","sidebar_label":"SAFROLE","description":"The Consensus Mechanism of Polkadot.","keywords":["consensus","proof of stake","nominated proof of stake","hybrid consensus","block production","sassafras","safrole","babe"],"slug":"../learn-safrole"},"sidebar":"docs","previous":{"title":"Elastic Scaling","permalink":"/docs/learn-elastic-scaling"},"next":{"title":"JAM","permalink":"/docs/learn-jam"}}');var s=n(74848),r=n(28453);const a={id:"learn-safrole",title:"Polkadot Block Production: SAFROLE",sidebar_label:"SAFROLE",description:"The Consensus Mechanism of Polkadot.",keywords:["consensus","proof of stake","nominated proof of stake","hybrid consensus","block production","sassafras","safrole","babe"],slug:"../learn-safrole"},i=void 0,l={},c=[{value:"Resources",id:"resources",level:2}];function d(e){const o={a:"a",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(o.p,{children:["SAFROLE (formerly known as SASSAFRAS) is a SNARK-based block production algorithm that provides\nanonymity in the validator selection process. SAFROLE also aims to deliver (nearly) fork-free,\nconstant time block production. SAFROLE is an upgrade to BABE, the block production portion of the\n",(0,s.jsx)(o.a,{href:"https://wiki.polkadot.network/docs/learn-consensus#hybrid-consensus",children:"hybrid consensus model"})," that\nPolkadot uses (and later JAM)."]}),"\n",(0,s.jsx)(o.p,{children:"zkSNARKs, in conjunction with a RingVRF, are used to ensure that slots are not preassigned to\nmalicious actors that are not part of the active validator set. Using a zkSNARK would allow\nanonymity to be preserved when a validator submits a ticket, proving they are in the active set\nwithout revealing their identity. This solution enables a validator to prove they are part of an\neligible group (via the RingVRF) while preserving anonymity within the block production mechanism\nand preventing the likelihood of spam."}),"\n",(0,s.jsxs)(o.p,{children:["Part of how SAFROLE minimizes the possibility of forks is by limiting the possibility of multiple\nvalid authors per six-second timeslot (the time to produce a block) where a valid, possible author\nmust only be a single key-holder from within a pre-specified group of validators. In other words, it\nlimits the possibility of two heads of the chain (built on the same parent) forming. More on how\nSAFROLE prevents forks can be found in\n",(0,s.jsx)(o.a,{href:"https://graypaper.com/graypaper.pdf",children:"Section 4.3, 4.8, and 6 of the JAM Graypaper."})]}),"\n",(0,s.jsx)(o.h2,{id:"resources",children:"Resources"}),"\n",(0,s.jsxs)(o.ul,{children:["\n",(0,s.jsx)(o.li,{children:(0,s.jsxs)(o.a,{href:"https://graypaper.com/graypaper.pdf",children:["The JAM Graypaper (see: ",(0,s.jsx)(o.strong,{children:"Block Production and Chain Growth"}),")"]})}),"\n",(0,s.jsxs)(o.li,{children:[(0,s.jsx)(o.a,{href:"https://research.web3.foundation/Polkadot/protocols/block-production/SASSAFRAS",children:"Web3 Foundation Research Page (SASSAFRAS)"}),"\nabout SASSAFRAS."]}),"\n"]})]})}function h(e={}){const{wrapper:o}={...(0,r.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},28453:(e,o,n)=>{n.d(o,{R:()=>a,x:()=>i});var t=n(96540);const s={},r=t.createContext(s);function a(e){const o=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function i(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(r.Provider,{value:o},e.children)}}}]);