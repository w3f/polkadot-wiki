"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2758],{3905:(e,a,t)=>{t.d(a,{Zo:()=>p,kt:()=>m});var o=t(67294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function r(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,o)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?r(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,o,n=function(e,a){if(null==e)return{};var t,o,n={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=o.createContext({}),c=function(e){var a=o.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},p=function(e){var a=c(e.components);return o.createElement(l.Provider,{value:a},e.children)},h="mdxType",d={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},u=o.forwardRef((function(e,a){var t=e.components,n=e.mdxType,r=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=c(t),u=n,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||r;return t?o.createElement(m,s(s({ref:a},p),{},{components:t})):o.createElement(m,s({ref:a},p))}));function m(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=t.length,s=new Array(r);s[0]=u;var i={};for(var l in a)hasOwnProperty.call(a,l)&&(i[l]=a[l]);i.originalType=e,i[h]="string"==typeof e?e:n,s[1]=i;for(var c=2;c<r;c++)s[c]=t[c];return o.createElement.apply(null,s)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},14865:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>p,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>h});var o=t(87462),n=t(63366),r=(t(67294),t(3905)),s=["components"],i={id:"learn-comparisons-ethereum-2",title:"Polkadot vs. Ethereum",sidebar_label:"Ethereum",description:"Comparison between Polkadot and Ethereum.",keywords:["ethereum","Ethereum","proof of stake","sharding"],slug:"../learn-comparisons-ethereum-2"},l=void 0,c={unversionedId:"learn/learn-comparisons-ethereum-2",id:"learn/learn-comparisons-ethereum-2",title:"Polkadot vs. Ethereum",description:"Comparison between Polkadot and Ethereum.",source:"@site/../docs/learn/learn-comparison-ethereum-2.md",sourceDirName:"learn",slug:"/learn-comparisons-ethereum-2",permalink:"/docs/learn-comparisons-ethereum-2",draft:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-comparison-ethereum-2.md",tags:[],version:"current",lastUpdatedBy:"bader y",lastUpdatedAt:1710152252,formattedLastUpdatedAt:"Mar 11, 2024",frontMatter:{id:"learn-comparisons-ethereum-2",title:"Polkadot vs. Ethereum",sidebar_label:"Ethereum",description:"Comparison between Polkadot and Ethereum.",keywords:["ethereum","Ethereum","proof of stake","sharding"],slug:"../learn-comparisons-ethereum-2"},sidebar:"docs",previous:{title:"Kusama",permalink:"/docs/learn-comparisons-kusama"},next:{title:"Cosmos",permalink:"/docs/learn-comparisons-cosmos"}},p={},h=[{value:"High-Level Comparison",id:"high-level-comparison",level:2},{value:"Scalability Approaches",id:"scalability-approaches",level:2},{value:"Rollups vs. Parachain Creation",id:"rollups-vs-parachain-creation",level:3},{value:"Architectural Differences: Polkadot and Ethereum",id:"architectural-differences-polkadot-and-ethereum",level:2},{value:"Forks, Upgrades, and Governance",id:"forks-upgrades-and-governance",level:3},{value:"Block Production &amp; Finalization",id:"block-production--finalization",level:3},{value:"Staking Mechanics: Ethereum PoS vs. Polkadot NPoS",id:"staking-mechanics-ethereum-pos-vs-polkadot-npos",level:3},{value:"Interoperability and Message Passing",id:"interoperability-and-message-passing",level:3},{value:"DApp Support and Development",id:"dapp-support-and-development",level:2},{value:"Conclusion",id:"conclusion",level:2}],d={toc:h},u="wrapper";function m(e){var a=e.components,t=(0,n.Z)(e,s);return(0,r.kt)(u,(0,o.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Both protocols are blockchains at their core but serve fundamentally different roles in how they are\nutilized:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ethereum is a general-purpose blockchain that hosts the Ethereum Virtual Machine, an environment\nfor executing smart contracts. Ethereum is homogenous but can utilize rollups and layer two\nsolutions to scale its usage."),(0,r.kt)("li",{parentName:"ul"},'Polkadot is a heterogeneous, multi-chain protocol (a "layer 0" or metaprotocol) that hosts\nmultiple layer one blockchains and allows them to partake in shared security. Polkadot acts as a\n',(0,r.kt)("strong",{parentName:"li"},"meta-protocol")," allowing multiple protocols to coexist and work together.")),(0,r.kt)("admonition",{title:"Sharding",type:"note"},(0,r.kt)("p",{parentName:"admonition"},'In the context of blockchains, the term "shards" or "sharded protocol" is typically used to refer to\nsub-protocols or as a general term to refer to a form of\n',(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Scalability#Horizontal_or_scale_out"},(0,r.kt)("strong",{parentName:"a"},"horizontal scaling")),".")),(0,r.kt)("h2",{id:"high-level-comparison"},"High-Level Comparison"),(0,r.kt)("p",null,"Both protocols have fundamentally different goals:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Ethereum is a general-purpose blockchain based on the Ethereum Virtual Machine (EVM). Ethereum is\nnot specialized nor optimized for any particular application. Instead, its primary focus is the\nEthereum Virtual Machine for executing smart contracts. Ethereum achieves scalability via\n",(0,r.kt)("a",{parentName:"p",href:"./learn-comparisons-rollups"},(0,r.kt)("strong",{parentName:"a"},"rollups"))," are secondary protocols that utilize Ethereum as a\nsettlement layer.")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},"Polkadot is a multi-chain protocol that provides shared security and secure interoperability for\neach of its ",(0,r.kt)("strong",{parentName:"p"},"parachains"),'. Each parachain (also called an "appchain" in this context) is\nspecialized towards a specific focus and optimized towards that goal. Parachains must abide by the\n',(0,r.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol"},"Parachains Protocol"),"."))),(0,r.kt)("p",null,"Polkadot ",(0,r.kt)("em",{parentName:"p"},"does not")," directly run a virtual machine for smart contracts, as Polkadot's primary\npurpose is to validate the protocols that operate under it."),(0,r.kt)("p",null,"However, several parachains provide\n",(0,r.kt)("a",{parentName:"p",href:"https://wiki.polkadot.network/docs/build-smart-contracts#parachains"},"smart contract functionality"),".\nParachains on Polkadot can even run an EVM for executing smart contracts written in Solidity using\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/polkadot-evm/frontier"},"Frontier, an Ethereum compatibility layer for Substrate"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"As a general summary, one could also say that Polkadot ",(0,r.kt)("strong",{parentName:"p"},"coordinates")," and ",(0,r.kt)("strong",{parentName:"p"},"validates"),"\nsub-protocols that follow the ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol"},"Parachains Protocol")," (which are\nakin to an optimistic-style rollup). In contrast, Ethereum coordinates inputs and outputs for the\nEVM. On Polkadot, any sub-protocol can have its own logic so long as it compiles to WebAssembly.")),(0,r.kt)("h2",{id:"scalability-approaches"},"Scalability Approaches"),(0,r.kt)("p",null,"Ethereum favors a ",(0,r.kt)("em",{parentName:"p"},"rollup-centric")," approach for scaling transaction throughput.\n",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/en/roadmap/danksharding/"},(0,r.kt)("strong",{parentName:"a"},"Danksharding"))," is how Ethereum plans to better\naccommodate and facilitate rollup activity by providing better utilities, such as data availability\nvia ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/roadmap/danksharding"},"Proto-Danksharding"),", for rollups to record state to\nEthereum."),(0,r.kt)("p",null,"Danksharding will allow for much more space to be utilized per block on Ethereum, where blobs of\ndata will be verifiable for an amount of time before being pruned from the network. This approach\nwill enable data availability at layer one and further enable layer two protocols on Ethereum to\nflourish more readily."),(0,r.kt)("p",null,"In contrast, Polkadot require parachains to\nregister themselves in accordance with the ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol"},"Parachains Protocol"),".\nOnce registered, Polkadot validates the state\ntransitions of each parachain as per their parachain validation function (PVF).\n",(0,r.kt)("a",{parentName:"p",href:"./learn-parachains-protocol#availability-and-unavailability-phase"},"Data availability")," is an\nintegral part of validating the parachain state. This approach enables parallelized interactions\nbetween parachains. They can trust that each sub-protocol's respective state is valid, as Polkadot\ncollectively validated them."),(0,r.kt)("h3",{id:"rollups-vs-parachain-creation"},"Rollups vs. Parachain Creation"),(0,r.kt)("p",null,"Ethereum primarily focuses on optimizing itself for rollups; Polkadot's parachains protocol allows\nvalidation to occur on the protocol level without needing a layer two solution."),(0,r.kt)("admonition",{title:"Rollup vs. Parachain Comparison",type:"info"},(0,r.kt)("p",{parentName:"admonition"},"For a more in-depth comparison of parachains versus rollups, take a look at the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-comparisons-rollups"},"rollup comparison page"))),(0,r.kt)("p",null,"On Polkadot, each parachain hosts its own core\nlogic, called a ",(0,r.kt)("strong",{parentName:"p"},"runtime")," (sometimes called a ",(0,r.kt)("strong",{parentName:"p"},"state transition function"),").\nPolkadot uses WebAssembly\n(",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-wasm"},"Wasm"),') as a "meta-protocol".'),(0,r.kt)("p",null,"Parachains have the option of using ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-xcm"},"cross-consensus messaging (XCM)")," to communicate\nwith one another and facilitate inter-chain reactions. It is also possible to utilize XCM on\nEthereum as it is merely a format for describing state transitions on a particular network."),(0,r.kt)("h2",{id:"architectural-differences-polkadot-and-ethereum"},"Architectural Differences: Polkadot and Ethereum"),(0,r.kt)("p",null,"As previously mentioned, Ethereum is a ",(0,r.kt)("strong",{parentName:"p"},"general-purpose")," virtual machine that can run sandboxed\nprograms are written in Solidity, whereas Polkadot is a meta-protocol for other parachains to\nconnect and interact with each other."),(0,r.kt)("p",null,"Ethereum operates as a single, homogeneous chain. Each Ethereum node is divided into two layers: the\n",(0,r.kt)("strong",{parentName:"p"},"consensus")," and ",(0,r.kt)("strong",{parentName:"p"},"execution")," layers. Each layer handles the block validation information, peer\ndiscovery, and Proof-of-Stake of the Ethereum client."),(0,r.kt)("p",null,"Polkadot's primary component is the ",(0,r.kt)("strong",{parentName:"p"},"relay chain"),", which hosts heterogeneous ",(0,r.kt)("strong",{parentName:"p"},"parachains"),". The\nrelay chain aggregates information from each parachain, where validators agree upon consensus and\nfinality. One can see Polkadot as a series of ",(0,r.kt)("strong",{parentName:"p"},"runtimes"),", which are state transition functions\nused to describe parachains and Polkadot itself."),(0,r.kt)("h3",{id:"forks-upgrades-and-governance"},"Forks, Upgrades, and Governance"),(0,r.kt)("p",null,"Ethereum's governance is done off-chain, where various stakeholders come to a consensus through some\nmedium other than the protocol itself. Upgrades on Ethereum will follow the standard hard fork\nprocedure, coordinating the community and validators to upgrade their nodes to implement protocol\nchanges."),(0,r.kt)("p",null,"Polkadot uses on-chain\n",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-polkadot-opengov"},"governance, called OpenGov"),", to facilitate upgrades to the Polkadot\nruntime. The stakeholders of Polkadot vote on these upgrades, and if successful, the upgrade is\nenacted automatically in the blocks to come. Polkadot validator operators only upgrade their nodes\nwhen the client itself gets updated."),(0,r.kt)("p",null,"Because of this mechanism, Polkadot can enact\nchain upgrades using the Wasm meta-protocol ",(0,r.kt)("em",{parentName:"p"},"without")," a hard fork. As the WebAssembly runtime for\nPolkadot (and all of its subsequent parachains) are stored on-chain, this involves simply replacing\nthe runtime with a new WebAssembly blob once governance allowed the upgrade to be enacted."),(0,r.kt)("p",null,"Anything within the state transition function, the transaction queue, or off-chain workers can be\nupgraded without forking the chain, as these are all part of the WebAssembly runtime."),(0,r.kt)("h3",{id:"block-production--finalization"},"Block Production & Finalization"),(0,r.kt)("p",null,"Both Ethereum and Polkadot use hybrid\nconsensus models where ",(0,r.kt)("strong",{parentName:"p"},"block production")," and ",(0,r.kt)("strong",{parentName:"p"},"finality")," are decoupled."),(0,r.kt)("p",null,"For finalization, Ethereum utilizes ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/glossary#casper-ffg"},"Casper FFG"),", which\nworks with ",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/glossary#lmd-ghost"},"LMD-GHOST")," as the fork choice rule for\nfinalization."),(0,r.kt)("p",null,"Polkadot utilizes ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-consensus#finality-gadget-grandpa"},"GRANDPA")," for finalization. Rather\nthan decide on a block-by-block basis, GRANDPA can finalize ",(0,r.kt)("em",{parentName:"p"},"chains")," of blocks. Both finalization\nmechanisms are both\n",(0,r.kt)("a",{parentName:"p",href:"https://www.geeksforgeeks.org/what-is-ghost-protocol-for-ethereum/"},"GHOST"),"-based and can both\nfinalize batches of blocks in one round."),(0,r.kt)("p",null,"For block production, both protocols use slot-based protocols that randomly assign validators to a\nslot and provide a fork choice rule for unfinalized blocks. Polkadot uses\n",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-consensus#badass-babe-sassafras"},"BABE")," for block production. BABE includes two\nmechanisms for selecting block producers, one of which is a fallback in case the first fails, which\nallows for chain liveness. BABE produces unfinalized blocks on top of the chain already finalized by\nGRANDPA."),(0,r.kt)("p",null,"There are two main differences between Ethereum and\nPolkadot consensus:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Polkadot's:polkadot }}","")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Ethereum typically has many validators per round (called an\n",(0,r.kt)("a",{parentName:"p",href:"https://ethereum.org/en/glossary/#epoch"},"epoch")," on Ethereum) to provide strong validity\nguarantees while Polkadot can provide\nstronger guarantees with fewer validators per round.\nPolkadot achieves this by making\nvalidators distribute an ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-parachains-protocol#erasure-codes"},"erasure coding")," to all\nvalidators in the system, such that anyone - not only the round's validators - can reconstruct a\nparachain's block and test its validity. This data availability is a core part of Polkadot -\nensuring state is valid for its state transitions. The random parachain-validator assignments\nand secondary checks are performed by randomly selected validators, making it less likely for\nthe small set of validators on each parachain to collude."))),(0,r.kt)("h3",{id:"staking-mechanics-ethereum-pos-vs-polkadot-npos"},"Staking Mechanics: Ethereum PoS vs. Polkadot NPoS"),(0,r.kt)("p",null,"Polkadot uses ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-phragmen"},"Nominated Proof of Stake (NPoS)")," to select validators from a\nsmaller set, letting smaller holders nominate validators to run the network while claiming the\nsystem's rewards without running a node. Polkadot needs about five validators for each parachain in\nthe network. For more information, see the ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-staking"},"staking page"),"."),(0,r.kt)("p",null,'Ethereum is a Proof of Stake (PoS) network that requires 32 ETH to stake for each validator\ninstance. Validators run a primary Beacon Chain node and multiple validator clients - one for each\n32 ETH. These validators get assigned to "committees," randomly selected groups to validate blocks\nin the network.'),(0,r.kt)("h3",{id:"interoperability-and-message-passing"},"Interoperability and Message Passing"),(0,r.kt)("p",null,"Polkadot uses\n",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-xcm"},"Cross-Consensus Messaging (XCM)")," for parachains to send arbitrary messages to each\nother. Parachains open connections with each other and can send messages via their established\nchannels. Given that ",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-collator"},"collators")," communicate directly to the relay chain, they\nwill be connected and can relay messages from parachain A to parachain B if needed through these\nmessage passing channels (see:\n",(0,r.kt)("a",{parentName:"p",href:"/docs/learn-xcm-transport"},"HRMP, VMP, and other message passing mechanisms for XCM"),")."),(0,r.kt)("p",null,"Messages do not pass through the relay chain. Only validity proofs and channel operations do (open,\nclose, etc.). This enhances scalability by keeping data on the edges of the system."),(0,r.kt)("p",null,"Currently, Ethereum rollups can communicate using\n",(0,r.kt)("a",{parentName:"p",href:"https://medium.com/@richardchen_81235/intro-to-shared-sequencing-1622d1fd51c9"},"shared sequencers"),",\nwhich provides a common ground of interoperability between layer two solutions."),(0,r.kt)("p",null,"Polkadot plans to have the concept of\n",(0,r.kt)("a",{parentName:"p",href:"/docs/polkadot-direction#xcm-and-accords"},(0,r.kt)("strong",{parentName:"a"},"Accords"))," are opt-in treaties for different\nprotocols to partake in. Accords ensure that logic about interoperability is kept consistent and\ncannot be changed and undermined by participating protocols. This helps ensure that any XCM message\ncan be properly interpreted and executed as needed on the target protocol in a fully trustless\nenvironment."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/learn-spree"},"SPREE (Shared Protected Runtime Execution Enclaves)")," is the mechanism that\nprovides shared logic for cross-consensus messages, and will be used to construct Accords."),(0,r.kt)("h2",{id:"dapp-support-and-development"},"DApp Support and Development"),(0,r.kt)("p",null,"Ethereum supports smart contract development using Solidity. These contracts are immutable, and\ncannot be changed once published on-chain."),(0,r.kt)("p",null,"Polkadot supports smart contracts through\nparachains, usually using the ",(0,r.kt)("a",{parentName:"p",href:"https://use.ink/"},"ink! smart contract language"),", but also Solidity\nthrough Frontier-enabled parachains. On Ethereum, smart contracts can call each other; however, they\nare fixed on-chain to the domain of Ethereum. On Polkadot, smart contracts can call each other in\nthe same parachain ",(0,r.kt)("em",{parentName:"p"},"and")," across parachains."),(0,r.kt)("p",null,"On Polkadot, developers have the option of either using smart contracts, calling extrinsics from\npallets that modify the chain's state in some particular way or merely use Polkadot's RPC to\ndirectly retrieve and act on-chain information. DApps on Polkadot are often composed of these\nmultiple components working together to modify, retrieve, and watch state changes live as they\nhappen."),(0,r.kt)("p",null,"For a more comprehensive list of how to build on Polkadot, be sure to check the\n",(0,r.kt)("a",{parentName:"p",href:"/docs/build-guide"},"Build Section"),"."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,'Ethereum and Polkadot both use a sharded\nmodel. Danksharding plans to utilize a rollup-centric approach by focusing on data availability. The\nPolkadot ecosystem is secured by a main chain,\ncalled the "relay chain," which in turn manages cores and allows tasks, such as parachains, to be\nrun on top of those cores and messages to be sent between them.'),(0,r.kt)("p",null,"The primary differences between the two protocols are:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Ethereum processes EVM-compatible state transitions, whether through rollups or on the mainnet\nitself, while Polkadot allows its parachains\nto have an abstract state transition function implementation."),(0,r.kt)("li",{parentName:"ul"},"Governance processes in Ethereum are planned to be off-chain and thus require coordination for a\nhard fork to enact governance decisions. In contrast, in\nPolkadot the decisions are on-chain and\nenacted autonomously via forkless upgrades."),(0,r.kt)("li",{parentName:"ul"},"Validator selection mechanisms differ as\nPolkadot can provide strong availability and\nvalidity guarantees with fewer validators per protocol.")))}m.isMDXComponent=!0}}]);