"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2493],{54758:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"general/polkadot-direction","title":"Polkadot Direction","description":"Polkadot as a Decentralized and Secure Ubiquitous Computer.","source":"@site/../docs/general/polkadot-direction.md","sourceDirName":"general","slug":"/polkadot-direction","permalink":"/docs/polkadot-direction","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/polkadot-wiki/edit/master/docs/general/polkadot-direction.md","tags":[],"version":"current","lastUpdatedBy":"github-actions[bot]","lastUpdatedAt":1730123236000,"frontMatter":{"id":"polkadot-direction","title":"Polkadot Direction","sidebar_label":"Polkadot Direction","description":"Polkadot as a Decentralized and Secure Ubiquitous Computer.","keywords":["polkadot vision","decentralization","ubiquitous computer","coretime","blockspace","cores"],"slug":"../polkadot-direction"},"sidebar":"docs","previous":{"title":"Polkadot 1.0","permalink":"/docs/polkadot-v1"},"next":{"title":"Stay Safe","permalink":"/docs/stay-safe-index"}}');var o=i(74848),t=i(28453);const s={id:"polkadot-direction",title:"Polkadot Direction",sidebar_label:"Polkadot Direction",description:"Polkadot as a Decentralized and Secure Ubiquitous Computer.",keywords:["polkadot vision","decentralization","ubiquitous computer","coretime","blockspace","cores"],slug:"../polkadot-direction"},r=void 0,c={},l=[{value:"Polkadot as a Computational Resource",id:"polkadot-as-a-computational-resource",level:2},{value:"Summary",id:"summary",level:2},{value:"From Slot Auctions to Coretime Marketplace",id:"from-slot-auctions-to-coretime-marketplace",level:2},{value:"From Chain-centricity to Application-centricity",id:"from-chain-centricity-to-application-centricity",level:2},{value:"XCM and Accords",id:"xcm-and-accords",level:3},{value:"Core Usage in Polkadot 1.0",id:"core-usage-in-polkadot-10",level:2},{value:"Agile Coretime Allocation",id:"agile-coretime-allocation",level:2},{value:"Split Coretime",id:"split-coretime",level:3},{value:"Strided Coretime",id:"strided-coretime",level:3},{value:"Combined Coretime",id:"combined-coretime",level:3},{value:"Agile Core Usage",id:"agile-core-usage",level:2},{value:"Compressed Cores",id:"compressed-cores",level:3},{value:"Shared Cores",id:"shared-cores",level:3},{value:"Agile Composable Computer",id:"agile-composable-computer",level:2},{value:"Polkadot&#39;s Resilience",id:"polkadots-resilience",level:2}];function d(e){const n={a:"a",admonition:"admonition",em:"em",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["The material on this page is based on\n",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=GIB1WeVuJD0",children:"Gavin Wood's talk at Polkadot Decoded 2023"}),"."]})}),"\n",(0,o.jsxs)(n.p,{children:["Understanding what ",(0,o.jsx)(n.a,{href:"/docs/polkadot-v1",children:"Polkadot 1.0"})," is about and the philosophy behind it will help\nus to envision the future direction of the Polkadot ecosystem toward abstraction and generalization."]}),"\n",(0,o.jsx)(n.h2,{id:"polkadot-as-a-computational-resource",children:"Polkadot as a Computational Resource"}),"\n",(0,o.jsxs)(n.p,{children:["Polkadot has been abstracted and generalized beyond what was originally proposed and envisioned in\nthe ",(0,o.jsx)(n.a,{href:"https://polkadot.network/whitepaper/",children:"whitepaper"}),". Polkadot is:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:["About ",(0,o.jsx)(n.a,{href:"/docs/polkadot-v1#polkadots-blockspace",children:(0,o.jsx)(n.strong,{children:"Blockspace"})})," (the underlying resources that\nchains need), not chains."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A platform to build applications"})," rather than chains and for people to use those applications.\nFundamentally, Polkadot is not a platform to host chains, and so far, chains happened to be one\nway to build applications and grow Polkadot's utility."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A provider of resilient general-purpose continuation computation"}),", where the term\n",(0,o.jsx)(n.em,{children:"continuation"})," refers to a broad, long-running task that can do something, pause, continue (or do\nsomething else) later."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"A multicore computer"})," where chains that continuously operate in parallel on different cores are\ncalled ",(0,o.jsx)(n.a,{href:"/docs/learn-parachains",children:"parachains"}),". One core can be reserved for one single chain\nin-bulk or on-demand. On-demand cores can be accessed by multiple chains at different periods (see\nthe ",(0,o.jsx)(n.a,{href:"/docs/learn-agile-coretime",children:"Agile Coretime page"}),"). At the time of writing (2024), there\nare around 50 cores independently operating in parallel on Polkadot."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["From now on ",(0,o.jsx)(n.em,{children:"application"})," will be used as a general term to describe anything that can use a\nPolkadot core to access secure and decentralized computation."]}),"\n",(0,o.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,o.jsx)(n.p,{children:"If we see Polkadot as a service provider of trustless and resilient computation through cores as\nwell as secure interoperability between core-powered applications, the future development of\nPolkadot can be directed towards the following main changes."}),"\n",(0,o.jsx)(n.p,{children:"A paradigm shift from:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"being a chain-focused ecosystem where each parachain owned an execution core at all times\n(acquired through fixed parachain auction), which allowed a simple and secure, sharded execution\nenvironment"}),"\n",(0,o.jsx)(n.li,{children:"to being an application-focused ecosystem where we remove the assumption that each application\nowns a core, and instead that all cores are a resource to be consumed and used as needed by all\napplications."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Previously, securing a core was a competitive process through an\n",(0,o.jsx)(n.a,{href:"/docs/learn/learn-auction",children:"auction mechanism"}),". With Agile Coretime, there is no need for\nauctions anymore. Teams can purchase on-demand coretime or reserve bulk coretime as required. This\ngreatly decreases the barrier-to-entry for software tinkerers and parachain teams."]}),"\n",(0,o.jsxs)(n.p,{children:["On top of those main changes, ",(0,o.jsx)(n.a,{href:"#agile-core-usage",children:"agile core usage"})," and\n",(0,o.jsx)(n.a,{href:"#agile-coretime-allocation",children:"coretime allocation"})," will allow any application to access Polkadot's\ncomputation based on their needs without wasting valuable blockspace. ",(0,o.jsx)(n.a,{href:"#xcm-and-accords",children:"Accords"}),"\nwill improve cross-chain communication and the security guarantees of XCM messages. Finally,\nPolkadot will scale by moving on-chain logic into its system parachains, allowing it to have more\nbandwidth for the ",(0,o.jsx)(n.a,{href:"/docs/learn-parachains-protocol",children:"parachains protocol"})," and accords."]}),"\n",(0,o.jsx)(n.h2,{id:"from-slot-auctions-to-coretime-marketplace",children:"From Slot Auctions to Coretime Marketplace"}),"\n",(0,o.jsxs)(n.p,{children:["The end product of blockchains is ",(0,o.jsx)(n.a,{href:"/docs/polkadot-v1#polkadots-blockspace",children:(0,o.jsx)(n.strong,{children:"Blockspace"})}),".\nApplications need to access Polkadot's blockspace, and the entry points to blockspace are the cores.\nThus, applications will need to reserve some time on cores or ",(0,o.jsx)(n.strong,{children:"Coretime"})," to gain the right to\naccess Polkadot's secure blockspace and interoperability for a finite period."]}),"\n",(0,o.jsx)(n.p,{children:"Cores must be agile and general: they can change what job they run as easily as a modern CPU. It\nfollows that the procurement of those cores must be agile as well."}),"\n",(0,o.jsx)(n.p,{children:"The auction mechanism is not agile, creates high entry barriers, and is designed for long-running\nsingle applications (i.e., the original Polkadot vision proposed in the whitepaper)."}),"\n",(0,o.jsxs)(n.p,{children:["We depart from the classic lease auctions and propose an agile marketplace for coretime, where\nessentially ",(0,o.jsx)(n.strong,{children:"coretime becomes a commodity that can be tokenized, sold, and traded"}),". This setup\nmaximizes the agility of Polkadot and lets the market figure out the best solution needed for\napplications to be successful."]}),"\n",(0,o.jsxs)(n.p,{children:["Applications can reserve ",(0,o.jsx)(n.strong,{children:"bulk coretime"})," and ",(0,o.jsx)(n.strong,{children:"on-demand coretime"})," depending on their needs. Bulk\ncoretime rental will be a standard rental of coretime through a broker system parachain at a fixed\nprice for a fixed period of time. On-demand coretime rental will be available through ongoing sale\nof coretime for immediate use at a spot price. This system lowers the barrier to entry for\nprospective builders."]}),"\n",(0,o.jsxs)(n.p,{children:["For example, revenues from coretime sales can be burnt, used to fund the Treasury, or used for a mix\nof those options. The topic is currently under discussion. For more information, see\n",(0,o.jsx)(n.a,{href:"https://github.com/polkadot-fellows/RFCs/pull/10",children:"RFC-0010"})," and\n",(0,o.jsx)(n.a,{href:"https://github.com/polkadot-fellows/RFCs/pull/17/files",children:"RFC-0015"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"from-chain-centricity-to-application-centricity",children:"From Chain-centricity to Application-centricity"}),"\n",(0,o.jsxs)(n.p,{children:["Polkadot 1.0 was a chain-centric paradigm consisting of isolated chains able to exchange messages.\nThis was not fundamentally different from having completely different chains connected to bridges,\nwith the only difference of having the relay chain securing the network, providing message-passing\ncapability, and doing some extra tasks such as ",(0,o.jsx)(n.a,{href:"/docs/learn-staking",children:"staking"}),",\n",(0,o.jsx)(n.a,{href:"./learn-accounts-index",children:"accounts"}),", ",(0,o.jsx)(n.a,{href:"/docs/learn-transactions#balance-transfers",children:"balances"}),",\nand ",(0,o.jsx)(n.a,{href:"/docs/learn-polkadot-opengov",children:"governance"}),". Having a chain-centric system will ultimately\nend in chain-centric application and UX."]}),"\n",(0,o.jsx)(n.p,{children:"The true innovation of Polkadot is about leveraging the unique value proposition offered by\ndifferent chains and using those chains\u2019 collaborative potential to build inter-chain applications\nto solve real-world problems. Those applications will thus need to span across chains."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Increasingly fewer tasks will be handled by the relay chain"})," that will focus efforts only on\nprimary tasks: securing the network and providing secure message-passing capability.\n",(0,o.jsx)(n.a,{href:"/docs/learn-system-chains",children:"System parachains"})," will be used to take over secondary relay chain\ntasks such as staking, governance, etc."]}),"\n",(0,o.jsx)(n.h3,{id:"xcm-and-accords",children:"XCM and Accords"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/docs/learn-xcm",children:"XCMP"})," is the transport layer for delivering XCM messages. It gives the\ntransportation method and a secure route but not a framework for binding agreements."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/docs/learn-xcm-transport",children:"XCM"})," is a format, a language of intention abstract over\nfunctionality common within chains. It creates an expressive language of what you intend to do or\nwant to happen. XCM messages are transported between different chains using XCMP. Ideally, in a\nfully trustless environment, strong guarantees ensure chains faithfully interpret XCM messages. We\ncan have a secure mode of delivering messages that can be interpreted across protocols, but still\nmessages might be misinterpreted. These guarantees can be achieved with accords."]}),"\n",(0,o.jsxs)(n.p,{children:["An ",(0,o.jsx)(n.strong,{children:"Accord"})," is an ",(0,o.jsx)(n.em,{children:"opt-in"})," treaty across many chains, where treaty logic cannot be changed or\nundermined by one or more of those chains, and Polkadot guarantees faithful execution of this logic.\nAccords will be specific to a particular function, and any chain that enters the accord will be held\nto it and will service that particular function. To lower the entry barrier, accords can be proposed\npermissionlessly, but because they are opt-in, the accord proposal will take effect until chains\nagree and sign up."]}),"\n",(0,o.jsx)(n.p,{children:"To sum up, accords ensure that the receiver faithfully interprets XCM messages securely sent via\nXCMP channels. Accords are the missing piece of the puzzle to achieve a fully trustless and\ncollaborative environment between applications."}),"\n",(0,o.jsx)(n.p,{children:"Polkadot is the only ecosystem where accords can properly exist because it has a homogenous security\nlayer that provides a specific state transition function for each logic component. This allows\npatterns of cooperation between multiple logic components (i.e., trans-applications) that would not\nbe possible to achieve over bridges."}),"\n",(0,o.jsxs)(n.p,{children:["Accords will be implemented using ",(0,o.jsx)(n.a,{href:"/docs/learn-spree",children:"SPREE technology"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"core-usage-in-polkadot-10",children:"Core Usage in Polkadot 1.0"}),"\n",(0,o.jsx)(n.p,{children:"In Polkadot 1.0, applications produced blocks at a fixed rate of 12 seconds, whether needed or not.\nThis led to inefficient energy allocation and economic incentives for producing full blocks under\nheavy traffic and empty blocks under light traffic."}),"\n",(0,o.jsx)(n.p,{children:"The figure below shows the core usage for Polkadot 1.0, where the horizontal axis is time, and each\nrow represents a core. Colors show different parachains, each using one core (i.e., one parachain,\none core formula)."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-dumb",src:i(32550).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsxs)(n.p,{children:["The above setup allowed a ",(0,o.jsx)(n.strong,{children:"simple and secure, sharded execution environment"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"However, to achieve full efficiency, blocks must be produced when needed, and the system must target\nfull block capacity, lowering the probability of incentivizing validators to build blocks half full\nor, worse, empty."}),"\n",(0,o.jsx)(n.h2,{id:"agile-coretime-allocation",children:"Agile Coretime Allocation"}),"\n",(0,o.jsxs)(n.p,{children:["In Polkadot 1.0, coretime is a fixed two-year period on one specific core. Here, we remove this\nlimitation and generalize coretime usage to meet different application needs. For more information,\nsee the ",(0,o.jsx)(n.a,{href:"/docs/learn-agile-coretime",children:"agile coretime documentation"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"split-coretime",children:"Split Coretime"}),"\n",(0,o.jsx)(n.p,{children:"Owners of coretime can split or trade it. An application A1 can run on core C1 for a finite period\nand then another application A2 can run on that core, or application A1 can continue running on\nanother core C2. Some applications might stop running for some time and resume later on."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-rangeSplit",src:i(67150).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.h3,{id:"strided-coretime",children:"Strided Coretime"}),"\n",(0,o.jsx)(n.p,{children:"Ranges can be strided (i.e., applications can take turns on a core) to share costs or decrease block\nproduction rate, for example."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-rangeStrided",src:i(6923).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.h3,{id:"combined-coretime",children:"Combined Coretime"}),"\n",(0,o.jsxs)(n.p,{children:["An application can be assigned to multiple cores simultaneously. Some applications can have a\npermanent core assignment and an intermittent one, for example, in a period of high demand to send\nmultiple blocks to multiple cores at the same time slot to reduce latency. Combining coretime in\nthis manner is achieved through ",(0,o.jsx)(n.a,{href:"/docs/learn-elastic-scaling",children:"elastic scaling"}),"."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-combined",src:i(41938).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.h2,{id:"agile-core-usage",children:"Agile Core Usage"}),"\n",(0,o.jsx)(n.p,{children:"In Polkadot 1.0, one core is assigned to one application (in this case, equivalent to a parachain).\nIdeally, core affinity (i.e., which application operates on which core) is unimportant (see below).\nCores do not have any higher friendliness to one application than another."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-dumb-noAffinity",src:i(7960).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.p,{children:"Here, we remove the assumption that each application owns a core and instead that all cores are a\nresource to be consumed and used as needed by all applications in the ecosystem."}),"\n",(0,o.jsx)(n.h3,{id:"compressed-cores",children:"Compressed Cores"}),"\n",(0,o.jsx)(n.p,{children:"The same core can secure multiple blocks of the same application simultaneously. Combining multiple\napplication blocks in the same relay chain core will reduce latency at the expense of increased\nbandwidth for the fixed price of opening and closing a block."}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-compressed",src:i(62720).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.h3,{id:"shared-cores",children:"Shared Cores"}),"\n",(0,o.jsxs)(n.p,{children:["Sharing cores with other applications to share costs but with no reduction in latency. Note that\nthis is different from the ",(0,o.jsx)(n.a,{href:"#split-coretime",children:"split coretime"})," where one core is used by multiple\napplication at different times to share costs at the expense of higher latency. Shared cores will be\nenabled with ",(0,o.jsx)(n.a,{href:"/docs/learn-jam-chain",children:"JAM"}),", a semi-coherent system in which data from different\nshards can be scheduled within the same core."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-shared",src:i(49984).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.h2,{id:"agile-composable-computer",children:"Agile Composable Computer"}),"\n",(0,o.jsxs)(n.p,{children:["All the above options of agile ",(0,o.jsx)(n.a,{href:"#agile-coretime-allocation",children:"coretime allocation"})," and\n",(0,o.jsx)(n.a,{href:"#agile-core-usage",children:"core usage"})," can be composable and enable the creation of an agile decentralized\nglobal computing system."]}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"core-usage-agile-composable",src:i(8420).A+"",width:"1920",height:"800"})}),"\n",(0,o.jsx)(n.p,{children:"Thus, this new vision is focused on Polkadot\u2019s resource, which is secure, flexible, and available\nblockspace that can be accessed by reserving some time on a core. Agility in allocating coretime and\nusing cores allows for maximized network efficiency and blockspace usage."}),"\n",(0,o.jsx)(n.h2,{id:"polkadots-resilience",children:"Polkadot's Resilience"}),"\n",(0,o.jsx)(n.p,{children:"Systems that have yet to be engineered with decentralization, cryptography, and game theory in mind,\nare breakable and prone to cyber-attacks. Polkadot is basing its resilience on different pillars:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Preponderance of light-client usage:"})," Centralized RPC servers are common but susceptible to\nattack and not trustless decentralized entry points to using blockchain-based applications. Light\nclient usage on Polkadot is possible through\n",(0,o.jsx)(n.a,{href:"/docs/build-light-clients#how-to-use-substrate-connect",children:"Smoldot"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Zero-Knowledge (ZK) Primitives:"})," They can have a problematic effect on censorship and\ncentralization as having a big state transition function boiled down to a single proof of correct\nexecution is not currently a scaling solution to build resilient systems. However, a library of\nrichly featured and high-performance ZK primitives ready for specific use cases is being built.\nThe first use-case will be used to improve privacy for on-chain collectives such as\n",(0,o.jsx)(n.a,{href:"/docs/learn-polkadot-technical-fellowship",children:"the Polkadot Technical Fellowship"}),"."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsxs)(n.strong,{children:[(0,o.jsx)(n.a,{href:"/docs/learn-safrole",children:"SAFROLE"})," consensus:"]})," New forkless block-production consensus\nalgorithm replacing ",(0,o.jsx)(n.a,{href:"/docs/learn-consensus#block-production-babe",children:"BABE"})," and where block are\nnot produced unless they are expected to be finalized. This will provide several benefits, such\nas:","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Improved security, parachain performance, and UX from being forkless"}),"\n",(0,o.jsx)(n.li,{children:"Preventing front-running attacks through high-performance transaction routing where transactions\nare included in blocks in one hop instead of being gossiped, and transaction encryption."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Internode Mixnet:"})," Shielded transport for short messages that","\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"avoids leaking IP information for transactions, and"}),"\n",(0,o.jsx)(n.li,{children:"introduces a general messaging system allowing users, chains and off-chain workers, smart\ncontracts, pallets, and anything else existing within a chain to exchange messages containing\nsignatures, intentions, etc."}),"\n"]}),"\n"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Social Decentralization:"})," Resilience is achieved by including many participants contributing to\nthe system and coming to decisions through on-chain governance. Involving as many people as\npossible ensures resilience against spending becoming systemically misjudged and appropriately\ndirects wealth for spending treasury funds, salaries, and grants. Another crucial way of\ndecentralizing the network is ensuring experts on which the maintenance of the system relies upon\nare incentivized and recruited over time by the Polkadot network and not by organizations within\nthe Polkadot ecosystem."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},41938:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-combined-4ef969fb72931430cf067bccc10c1a73.png"},8420:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-composable-ee626ebd055fdf3bbd6d88d70bc2c110.png"},62720:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-compressed-db4821b411e6f4be0c12167d89ee022e.png"},67150:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-rangeSplit-d8511cbb8658052ac0a639bd6a722982.png"},6923:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-rangeStrided-605254487f94721806beca92707cfaf3.png"},49984:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-agile-shared-f395560cce9a4fd4976c5259ce8c67c4.png"},7960:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-dumb-noAffinity-8d86655d36adc7c8de32114821a1764a.png"},32550:(e,n,i)=>{i.d(n,{A:()=>a});const a=i.p+"assets/images/core-usage-dumb-6419ee60a3606e10d89a1c91dbf24e20.png"},28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>r});var a=i(96540);const o={},t=a.createContext(o);function s(e){const n=a.useContext(t);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),a.createElement(t.Provider,{value:n},e.children)}}}]);