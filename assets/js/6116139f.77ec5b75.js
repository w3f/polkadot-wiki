"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4840],{53932:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>r});var i=n(74848),t=n(28453);const s={id:"learn-elastic-scaling",title:"Polkadot's Elastic Scaling",sidebar_label:"Elastic Scaling",description:"Enabling parachains to scale on-demand through instantaneous coretime.",keywords:["elastic scaling","parachains","coretime","blockspace"],slug:"../learn-elastic-scaling"},c=void 0,o={id:"learn/learn-elastic-scaling",title:"Polkadot's Elastic Scaling",description:"Enabling parachains to scale on-demand through instantaneous coretime.",source:"@site/../docs/learn/learn-elastic-scaling.md",sourceDirName:"learn",slug:"/learn-elastic-scaling",permalink:"/docs/learn-elastic-scaling",draft:!1,unlisted:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-elastic-scaling.md",tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1712052468e3,frontMatter:{id:"learn-elastic-scaling",title:"Polkadot's Elastic Scaling",sidebar_label:"Elastic Scaling",description:"Enabling parachains to scale on-demand through instantaneous coretime.",keywords:["elastic scaling","parachains","coretime","blockspace"],slug:"../learn-elastic-scaling"},sidebar:"docs",previous:{title:"SPREE",permalink:"/docs/learn-spree"},next:{title:"SAFROLE",permalink:"/docs/learn-safrole"}},l={},r=[{value:"Technical Considerations",id:"technical-considerations",level:2}];function h(e){const a={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(a.p,{children:["The path of parablocks from their creation to their inclusion into the relay chain (discussed in the\n",(0,i.jsx)(a.a,{href:"/docs/learn-parachains-protocol",children:"Parachain Protocol Page"}),") spans two domains: the parachain's and\nrelay chain's. Scaling the Polkadot protocol involves consideration of how parablocks are produced\nby the parachain and then validated, processed, secured, made available for additional checks, and\nfinally included on the relay chain."]}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.a,{href:"/docs/learn-async-backing",children:"Asynchronous backing"})," is the optimization implemented on the relay chain\nthat allows parachains to produce blocks faster and allows relay chain to process them seamlessly.\nAsynchronous backing also improves the parachain side with unincluded segments and augmented info\nthat allows collators to produce multiple parablocks even if the previous blocks are not yet\nincluded. This upgrade allows parachains to utilize up to 2 seconds execution time per parablock,\nand the relay chain will be able to include a parablock every 6 seconds."]}),"\n",(0,i.jsx)(a.p,{children:"With elastic scaling, parachains can use multiple cores to include multiple parablocks within the\nsame relay chain block."}),"\n",(0,i.jsx)(a.p,{children:"The relay chain receives a sequence of parachain blocks on multiple cores, which are validated and\nchecked if all their state roots line up during their inclusion, but assume they\u2019re unrelated\nparachain blocks during backing, availability, and approvals. With elastic scaling implemented, a\nparachain's throughput depends upon its collator infrastructure."}),"\n",(0,i.jsxs)(a.p,{children:["The ",(0,i.jsx)(a.a,{href:"https://github.com/paritytech/polkadot-sdk/issues/1829",children:"elastic scaling implementation"})," will be\nrolled out in multiple phases. In the first phase, elastic scaling is set to work on parachains with\na trusted/permissioned collator set. With this restriction, it is possible to launch elastic scaling\nwithout changing the candidate receipt. After successfully implementing the first phase, changes can\nbe made to the candidate receipt so the collator set can be untrusted/permissionless again. The\nfinal phase will feature full integration with the Cumulus framework, enabling parachains to be\nconfigured to access multiple cores continuously."]}),"\n",(0,i.jsx)(a.p,{children:"Take, for example, a parachain that wants to submit four parablocks to the relay chain. Without\nelastic scaling, it will take 24 seconds to include all of them through one core. Remember that a\ncore is occupied after backing and before inclusion, i.e., for the whole data availability process.\nA block cannot enter a core before the previous block has been declared available."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{children:"              R1 <----- R2 <----- R3 <----- R4 <----- R5\n\nC1    |P1     B          I\n      |P2                B         I\n      |P3                          B         I\n      |P4                                    B         I\n\n"})}),"\n",(0,i.jsx)(a.p,{children:"The diagram above shows how the backing and inclusion of parablocks (P) happen within the same relay\nchain block (R). With one core (C1), a parablock is included every 6 seconds. Note how P4 is\nincluded after 30 seconds (not 24 seconds) because when P1 was pushed to the relay chain for being\nbacked, there was no previous parablock."}),"\n",(0,i.jsx)(a.p,{children:"With elastic scaling, it will take just 12 seconds (3-second block time) to include all four\nparablocks using two cores."}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{children:"              R1 <----- R2 <----- R3\n\nC1    |P1     B          I\n      |P2                B         I\nC2    |P3     B          I\n      |P4                B         I\n\n"})}),"\n",(0,i.jsx)(a.p,{children:"The diagram above shows how four parablocks are backed and included in the relay chain using two\ncores (C1 and C2). Note how P2 and P4 are included after 18 seconds (not 12 seconds) because when P1\nand P3 were pushed to the relay chain for being backed, there were no other parablocks before them."}),"\n",(0,i.jsx)(a.h2,{id:"technical-considerations",children:"Technical Considerations"}),"\n",(0,i.jsx)(a.p,{children:"If the pace per core on the relay chain will not change (backing and inclusion every 6 seconds per\ncore), on the parachain side, collators will need to increase the parablock production rate to push\nP1 and P2 to the two relay chain cores."}),"\n",(0,i.jsx)(a.p,{children:"Assuming a constant number of cores, from the relay chain side, elastic scaling will not see major\nupgrades as a parachain will use multiple existing cores instead of just one. However, from the\nparachain side, collators must produce more parablocks per unit of time, implying that technical\nspecifications for collators will likely increase."}),"\n",(0,i.jsxs)(a.p,{children:["For more advanced technical challenges, see the\n",(0,i.jsx)(a.a,{href:"https://github.com/paritytech/polkadot-sdk/issues/1829",children:"Elastic Scaling GitHub PR"}),"."]})]})}function d(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},28453:(e,a,n)=>{n.d(a,{R:()=>c,x:()=>o});var i=n(96540);const t={},s=i.createContext(t);function c(e){const a=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),i.createElement(s.Provider,{value:a},e.children)}}}]);