"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6],{3905:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>p});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},h=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=c(a),p=i,m=u["".concat(l,".").concat(p)]||u[p]||d[p]||o;return a?n.createElement(m,r(r({ref:t},h),{},{components:a})):n.createElement(m,r({ref:t},h))}));function p(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},11982:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>h,contentTitle:()=>l,default:()=>p,frontMatter:()=>s,metadata:()=>c,toc:()=>d});var n=a(87462),i=a(63366),o=(a(67294),a(3905)),r=["components"],s={id:"learn-transaction-fees",title:"Transaction Fees",sidebar_label:"Transaction Fees",description:"How transaction fees are calculated and handled.",keywords:["transaction","fees"],slug:"../learn-transaction-fees"},l=void 0,c={unversionedId:"learn/learn-transaction-fees",id:"learn/learn-transaction-fees",title:"Transaction Fees",description:"How transaction fees are calculated and handled.",source:"@site/../docs/learn/learn-transaction-fees.md",sourceDirName:"learn",slug:"/learn-transaction-fees",permalink:"/docs/learn-transaction-fees",draft:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-transaction-fees.md",tags:[],version:"current",lastUpdatedBy:"Keith Alfaro",lastUpdatedAt:1670841651,formattedLastUpdatedAt:"Dec 12, 2022",frontMatter:{id:"learn-transaction-fees",title:"Transaction Fees",sidebar_label:"Transaction Fees",description:"How transaction fees are calculated and handled.",keywords:["transaction","fees"],slug:"../learn-transaction-fees"},sidebar:"docs",previous:{title:"Runtime Upgrades",permalink:"/docs/learn-runtime-upgrades"},next:{title:"Treasury",permalink:"/docs/learn-treasury"}},h={},d=[{value:"Fee Calculation",id:"fee-calculation",level:2},{value:"Block Limits and Transaction Priority",id:"block-limits-and-transaction-priority",level:2},{value:"Fees",id:"fees",level:2},{value:"Fee Multiplier",id:"fee-multiplier",level:3},{value:"Calcuating Fees with Polkadot-JS",id:"calcuating-fees-with-polkadot-js",level:2},{value:"Shard Transactions",id:"shard-transactions",level:2},{value:"Other Resource Limitation Strategies",id:"other-resource-limitation-strategies",level:2},{value:"Advanced",id:"advanced",level:2},{value:"Learn More",id:"learn-more",level:2}],u={toc:d};function p(e){var t=e.components,a=(0,i.Z)(e,r);return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Several resources in a blockchain network are limited, for example, storage and computation.\nTransaction fees prevent individual users from consuming too many resources.\nPolkadot uses a weight-based fee model as\nopposed to a gas-metering model. As such, fees are charged prior to transaction execution; once the\nfee is paid, nodes will execute the transaction."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://w3f-research.readthedocs.io/en/latest/polkadot/overview/2-token-economics.html?highlight=transaction%20fee"},"Web3 Foundation Research"),"\ndesigned the Polkadot fee system with the following objectives:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Each Relay Chain block should be processed efficiently to avoid delays in block production."),(0,o.kt)("li",{parentName:"ul"},"The growth rate of the Relay Chain should be bounded."),(0,o.kt)("li",{parentName:"ul"},"Each block should have space for special, high-priority transactions like misconduct reports."),(0,o.kt)("li",{parentName:"ul"},"The system should be able to handle spikes in demand."),(0,o.kt)("li",{parentName:"ul"},"Fees should change slowly so that senders can accurately predict the fee for a given transaction.")),(0,o.kt)("h2",{id:"fee-calculation"},"Fee Calculation"),(0,o.kt)("p",null,"Fees on the Polkadot Relay Chain are calculated based on three parameters:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"A Weight fee",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Base weight"),(0,o.kt)("li",{parentName:"ul"},"Call(s) weight"))),(0,o.kt)("li",{parentName:"ul"},"A Length fee"),(0,o.kt)("li",{parentName:"ul"},"A Tip (optional).")),(0,o.kt)("p",null,"As a permissionless system, the Polkadot\nnetwork needs to implement a mechanism to measure and to limit the usage in order to establish an\neconomic incentive structure, to prevent the network overload, and to mitigate DoS vulnerabilities.\nPolkadot enforces a limited time-window for\nblock producers to create a block, including limitations on block size, which can make the selection\nand execution of certain extrinsics too expensive and decelerate the network. Extrinsics which\nrequire too many resources are discarded by the network."),(0,o.kt)("p",null,"Polkadot defines a specified\n",(0,o.kt)("a",{parentName:"p",href:"https://spec.polkadot.network/#sect-limitations"},"block ratio")," ensuring that only a certain portion\nof the total block size gets used for regular extrinsics. The remaining space is reserved for\ncritical, operational extrinsics required for the functionality by network itself."),(0,o.kt)("p",null,"This is handled by a ",(0,o.kt)("a",{parentName:"p",href:"/docs/glossary#weights"},"weight")," system, where the cost of the\ntransactions (referred to as ",(0,o.kt)("a",{parentName:"p",href:"/docs/glossary#extrinsics"},"extrinsics")," are determined before\nexecution. Weights are a fixed set of numbers used in Substrate-based chains to manage the time it\ntakes to validate a block. Each transaction has a base weight that accounts for the overhead of\ninclusion (e.g. signature verification) and a dispatch weight that accounts for the time to execute\nthe transaction. All weights, even the base weight, are a measure of time to execute on some\nstandard hardware."),(0,o.kt)("p",null,"The runtime\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.substrate.io/reference/how-to-guides/weights/calculate-fees/"},"converts weight units to balance units"),"\nas part of the fee calculation."),(0,o.kt)("p",null,"The weight fee is the sum of the base weight and the sum of the total weight consumed by call(s)."),(0,o.kt)("admonition",{title:"A transaction can include several calls",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"For instance, a ",(0,o.kt)("inlineCode",{parentName:"p"},"batch")," can contain ",(0,o.kt)("inlineCode",{parentName:"p"},"bond")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nominate"),", and the weight would be one base weight\nand then the sum of the weights for ",(0,o.kt)("inlineCode",{parentName:"p"},"bond")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"nominate"),".")),(0,o.kt)("p",null,"To learn more about the motivation of a weight fee, check out this\n",(0,o.kt)("a",{parentName:"p",href:"https://docs.substrate.io/main-docs/build/tx-weights-fees/"},"Substrate doc")," on weights."),(0,o.kt)("p",null,"The length fee is a per-byte fee multiplier for the size of the transaction in bytes."),(0,o.kt)("p",null,"There is also a targeted fee adjustment that serves as a multiplier which tunes the final fee based\non network congestion. This can constitute an adjusted weight fee calculated as the targeted fee\nadjustment times the weight fee."),(0,o.kt)("p",null,"Together, these fees constitute the inclusion fee. The inclusion fee is the base fee plus the length\nfee plus the adjusted weight fee."),(0,o.kt)("p",null,"The inclusion fee is deducted from the sender's account before transaction execution. A portion of\nthe fee will go to the block author, and the remainder will go to the ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-treasury"},"Treasury"),".\nThis is 20% and 80%, respectively."),(0,o.kt)("p",null,"Tips are an optional transaction fee that users can add. Tips are not part of the inclusion fee and\nare an incentive to block authors for prioritizing a transaction, and the entire tip goes directly\nto the block author."),(0,o.kt)("p",null,'Final weights are assigned based on the worst case scenario of each runtime function. The runtime\nhas the ability to "refund" the amount of weight which was overestimated once the runtime function\nis actually executed.'),(0,o.kt)("p",null,"The runtime only returns weights if the difference between the assigned weight and the actual weight\ncalculated during execution is greater than 20%."),(0,o.kt)("p",null,"Checkout some examples of how various weights are gauged in the\nPolkadot runtime for several different types\nof operations:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://spec.polkadot.network/#sect-practical-examples"},"request_judgement")," - from the identity\npallet, allows users to request judgement from a specific registrar"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://spec.polkadot.network/#sect-practical-example-payout-stakers"},"payout_stakers")," - from the\nstaking Pallet, is invoked by a single account in order to payout the reward for all nominators\nwho back a particular validator"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://spec.polkadot.network/#_practical_example_3_transfer"},"transfer")," - from the balances\nmodule, is designed to move the specified balance by the sender to the receiver"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://spec.polkadot.network/#_practical_example_4_withdraw_unbounded"},"withdraw_unbounded")," -\nfrom the staking module, is designed to move any unlocked funds from the staking management system\nto be ready for transfer")),(0,o.kt)("h2",{id:"block-limits-and-transaction-priority"},"Block Limits and Transaction Priority"),(0,o.kt)("p",null,"Blocks in Polkadot have both a maximum length\n(in bytes) and a maximum weight. Block producers will fill blocks with transactions up to these\nlimits. A portion of each block - currently 25% - is reserved for critical transactions that are\nrelated to the chain's operation. Block producers will only fill up to 75% of a block with normal\ntransactions. Some examples of operational transactions:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Misbehavior reports"),(0,o.kt)("li",{parentName:"ul"},"Council operations"),(0,o.kt)("li",{parentName:"ul"},"Member operations in an election (e.g. renouncing candidacy)")),(0,o.kt)("p",null,"Block producers prioritize transactions based on each transaction's total fee. Since a portion of\nthe fee will go to the block producer, producers will include the transactions with the highest fees\nto maximize their reward."),(0,o.kt)("h2",{id:"fees"},"Fees"),(0,o.kt)("p",null,"Block producers charge a fee in order to be economically sustainable. That fee must always be\ncovered by the sender of the transaction.\nPolkadot has a flexible mechanism to determine\nthe minimum cost to include transactions in a block."),(0,o.kt)("p",null,"Transaction volume on blockchains is highly irregular, and therefore transaction fees need a\nmechanism to adjust. However, users should be able to predict transaction fees."),(0,o.kt)("p",null,"Polkadot uses a slow-adjusting fee mechanism\nwith tips to balance these two considerations. In addition to block ",(0,o.kt)("em",{parentName:"p"},"limits"),",\nPolkadot also has a block fullness ",(0,o.kt)("em",{parentName:"p"},"target."),"\nFees increase or decrease for the next block based on the fullness of the current block relative to\nthe target. The per-weight fee can change up to 30% in a 24 hour period. This rate captures\nlong-term trends in demand, but not short-term spikes. To consider short-term spikes,\nPolkadot uses tips on top of the length and\nweight fees. Users can optionally add a tip to the fee to give the transaction a higher priority."),(0,o.kt)("p",null,"Polkadot fees consists of three parts:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Base fee"),": a fixed fee that is applied to every transaction and set by the runtime."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Length fee"),": a fee that gets multiplied by the length of the transaction, in bytes."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"Weight fee"),": a fee for each, varying runtime function. Runtime implementers need to implement a\nconversion mechanism which determines the corresponding currency amount for the calculated\nweight.")),(0,o.kt)("p",null,"The final fee can be summarized as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"fee = base_fee + length_of_transaction_in_bytes * length_fee + weight_fee\n")),(0,o.kt)("p",null,"For example, the Polkadot Runtime defines the following values:"),(0,o.kt)("p",null,"Base fee: 100 uDOTs"),(0,o.kt)("p",null,"Length fee: Length fee: 0.1 uDOTs"),(0,o.kt)("p",null,"So, the weight to fee conversion is calculated as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"weight_fee = weight * (100 uDots / (10 * 10\u2019000))\n")),(0,o.kt)("p",null,"A weight of 10\u2019000 (the smallest non-zero weight) is mapped to 1/10 of 100 uDOT. This fee will never\nexceed the max size of an unsigned 128 bit integer."),(0,o.kt)("h3",{id:"fee-multiplier"},"Fee Multiplier"),(0,o.kt)("p",null,"Polkadot can add a additional fee to\ntransactions if the network becomes too busy and starts to decelerate the system. This fee can\ncreate an incentive to avoid the production of low priority or insignificant transactions. In\ncontrast, those additional fees will decrease if the network calms down and can execute transactions\nwithout much difficulties."),(0,o.kt)("p",null,"This additional fee is known as the ",(0,o.kt)("inlineCode",{parentName:"p"},"Fee Multiplier")," and its value is defined by the\nPolkadot runtime. The multiplier works by\ncomparing the saturation of blocks; if the previous block is less saturated than the current block\n(implying an uptrend), the fee is slightly increased. Similarly, if the previous block is more\nsaturated than the current block (implying a downtrend), the fee is slightly decreased."),(0,o.kt)("p",null,"The final fee is calculated as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"final_fee = fee * fee_multiplier\n")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Update Multiplier")," defines how the multiplier can change. Each runtime has the ability to\ndefine this behavior accordingly. For example, the\nPolkadot runtime internally updates the\nmultiplier after each block according to a custom formula defined\n",(0,o.kt)("a",{parentName:"p",href:"https://spec.polkadot.network/#_update_multiplier"},"here"),"."),(0,o.kt)("h2",{id:"calcuating-fees-with-polkadot-js"},"Calcuating Fees with Polkadot-JS"),(0,o.kt)("p",null,"One useful utility for estimating transaction fees programmatically is the via the\n",(0,o.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/@polkadot/api"},"@polkadot/api"),". Check out the following script that\nlogs some relevant fee information:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"// Estimate the fees as RuntimeDispatchInfo using the signer\nconst info = await api.tx.balances.transfer(recipient, 123).paymentInfo(sender);\n\n// Log relevant info, partialFee is Balance, estimated for current\nconsole.log(`\n  class=${info.class.toString()},\n  weight=${info.weight.toString()},\n  partialFee=${info.partialFee.toHuman()}\n`);\n")),(0,o.kt)("p",null,"For additional information on interacting with the API, checkout ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-polkadotjs"},"Polkadot-JS"),"."),(0,o.kt)("h2",{id:"shard-transactions"},"Shard Transactions"),(0,o.kt)("p",null,"The transactions that take place within\nPolkadot's shards - parachains and\nparathreads - do not incur Relay Chain transaction fees. Users of shard applications do not even\nneed to hold DOT tokens, as each shard has its own economic model and may or may not have a token.\nThere are, however, situations where shards themselves make transactions on the Relay Chain."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/learn-parachains"},"Parachains")," have a dedicated slot on the Relay Chain for execution, so their\ncollators do not need to own DOT in order to include blocks. The parachain will make some\ntransactions itself, for example, opening or closing an ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-xcm"},"XCM")," channel, participating\nin an ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-auction"},"auction")," to renew its slot, or upgrading its runtime. Parachains have their\nown accounts on the Relay Chain and will need to use those funds to issue transactions on the\nparachain's behalf."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"/docs/learn-parathreads"},"Parathreads")," will also make all the same transactions that a parachain might.\nIn addition, the collators need to participate in an auction every block to progress their chain.\nThe collators will need to have DOT to participate in these auctions."),(0,o.kt)("h2",{id:"other-resource-limitation-strategies"},"Other Resource Limitation Strategies"),(0,o.kt)("p",null,"Transaction weight must be computable prior to execution, and therefore can only represent fixed\nlogic. Some transactions warrant limiting resources with other strategies. For example:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Bonds: Some transactions, like voting, may require a bond that will be returned or slashed after\nan on-chain event. In the voting example, returned at the end of the election or slashed if the\nvoter tried anything malicious."),(0,o.kt)("li",{parentName:"ul"},"Deposits: Some transactions, like setting an ",(0,o.kt)("a",{parentName:"li",href:"/docs/learn-identity"},"identity")," or claiming an index,\nuse storage space indefinitely. These require a deposit that will be returned if the user decides\nto free storage (e.g. clear their IDE)."),(0,o.kt)("li",{parentName:"ul"},"Burns: A transaction may burn funds internally based on its logic. For example, a transaction may\nburn funds from the sender if it creates new storage entries, thus increasing the state size."),(0,o.kt)("li",{parentName:"ul"},"Limits: Some limits are part of the protocol. For example, nominators can only nominate 16\nvalidators. This limits the complexity of ",(0,o.kt)("a",{parentName:"li",href:"/docs/learn-phragmen"},"Phragm\xe9n"),".")),(0,o.kt)("h2",{id:"advanced"},"Advanced"),(0,o.kt)("p",null,'This page only covered transactions that come from normal users. If you look at blocks in a block\nexplorer, though, you may see some "extrinsics" that look different from these transactions. In\nPolkadot (and any chain built on Substrate),\nan extrinsic is a piece of information that comes from outside the chain. Extrinsics fall into three\ncategories:'),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Signed transactions"),(0,o.kt)("li",{parentName:"ul"},"Unsigned transactions"),(0,o.kt)("li",{parentName:"ul"},"Inherents")),(0,o.kt)("p",null,"This page only covered signed transactions, which is the way that most users will interact with\nPolkadot . Signed transactions come from an\naccount that has funds, and therefore Polkadot\ncan charge a transaction fee as a way to prevent spam."),(0,o.kt)("p",null,"Unsigned transactions are for special cases where a user needs to submit an extrinsic from a key\npair that does not control funds. For example, when users\n",(0,o.kt)("a",{parentName:"p",href:"https://claims.polkadot.network"},"claim their DOT tokens")," after genesis, their DOT address doesn't\nhave any funds yet, so that uses an unsigned transaction. Validators also submit unsigned\ntransactions in the form of \"heartbeat\" messages to indicate that they are online. These heartbeats\nmust be signed by one of the validator's ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn-cryptography"},"session keys"),". Session keys never\ncontrol funds. Unsigned transactions are only used in special cases because, since Polkadot cannot\ncharge a fee for them, each one needs its own, custom validation logic."),(0,o.kt)("p",null,'Finally, inherents are pieces of information that are not signed or included in the transaction\nqueue. As such, only the block author can add inherents to a block. Inherents are assumed to be\n"true" simply because a sufficiently large number of validators have agreed on them being\nreasonable. For example, Polkadot blocks\ninclude a timestamp inherent. There is no way to prove that a timestamp is true the way one proves\nthe desire to send funds with a signature. Rather, validators accept or reject the block based on\nhow reasonable they find the timestamp. In\nPolkadot, it must be within some acceptable\nrange of their own system clocks.'),(0,o.kt)("h2",{id:"learn-more"},"Learn More"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://research.web3.foundation/en/latest/polkadot/overview/2-token-economics.html"},"Web3 Foundation Research")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://docs.substrate.io/main-docs/build/tx-weights-fees/"},"Substrate Extrinsics, Weights & Fees"))))}p.isMDXComponent=!0}}]);