"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4168],{53158:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>l,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"learn/xcm/quickstart/learn-xcm-docs-quickstart-first-look","title":"First Look at an XCM","description":"First Look at an XCM.","source":"@site/../docs/learn/xcm/quickstart/first-look.md","sourceDirName":"learn/xcm/quickstart","slug":"/learn/xcm/quickstart-first-look","permalink":"/docs/learn/xcm/quickstart-first-look","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/xcm/quickstart/first-look.md","tags":[],"version":"current","lastUpdatedBy":"bader y","lastUpdatedAt":1694099593000,"frontMatter":{"id":"learn-xcm-docs-quickstart-first-look","title":"First Look at an XCM","sidebar_label":"First Look at an XCM","description":"First Look at an XCM.","keywords":["xcm","cross-consensus messaging"],"slug":"../quickstart-first-look"},"sidebar":"docs","previous":{"title":"XCM Simulator","permalink":"/docs/learn/xcm/quickstart-simulator"},"next":{"title":"Fundamentals","permalink":"/docs/learn/xcm/fundamentals"}}');var i=n(74848),o=n(28453);const r={id:"learn-xcm-docs-quickstart-first-look",title:"First Look at an XCM",sidebar_label:"First Look at an XCM",description:"First Look at an XCM.",keywords:["xcm","cross-consensus messaging"],slug:"../quickstart-first-look"},a="First Look",c={},h=[{value:"Message",id:"message",level:2},{value:"WithdrawAsset",id:"withdrawasset",level:3},{value:"BuyExecution",id:"buyexecution",level:3},{value:"DepositAsset",id:"depositasset",level:3},{value:"What next?",id:"what-next",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"first-look",children:"First Look"})}),"\n",(0,i.jsxs)(t.p,{children:["In this section, we take you through a simple example of an XCM. In this example, we withdraw the\nnative token from the account of Alice and deposit this token in the account of Bob. This message\nsimulates a transfer between two accounts in the same consensus system (",(0,i.jsx)(t.code,{children:"ParaA"}),"). You can find the\ncomplete code example ",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/xcm-docs/tree/main/examples",children:"in the repo"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"message",children:"Message"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:" let message = Xcm(vec![\n    WithdrawAsset((Here, amount).into()),\n    BuyExecution{ fees: (Here, amount).into(), weight_limit: WeightLimit::Unlimited },\n    DepositAsset {\n        assets: All.into(),\n        beneficiary:  MultiLocation {\n            parents: 0,\n            interior: Junction::AccountId32 {\n                network: None,\n                id: BOB.clone().into()\n            }.into(),\n        }.into()\n    }\n]);\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The message consists of three instructions: ",(0,i.jsx)(t.code,{children:"WithdrawAsset"}),", ",(0,i.jsx)(t.code,{children:"BuyExecution"}),", and ",(0,i.jsx)(t.code,{children:"DepositAsset"}),". In\nthe following sections we will go over each instruction."]}),"\n",(0,i.jsx)(t.h3,{id:"withdrawasset",children:"WithdrawAsset"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"WithdrawAsset((Here, amount).into())\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The first instruction takes as an input the MultiAsset that should be withdrawn. The MultiAsset\ndescribes the native parachain token with the ",(0,i.jsx)(t.code,{children:"Here"})," keyword. The ",(0,i.jsx)(t.code,{children:"amount"})," parameter is the number\nof tokens that are transferred. The withdrawal account depends on the origin of the message. In this\nexample the origin of the message is Alice. The WithdrawAsset instruction moves ",(0,i.jsx)(t.code,{children:"amount"})," number of\nnative tokens from Alice's account into the ",(0,i.jsx)(t.em,{children:"holding register"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"buyexecution",children:"BuyExecution"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"BuyExecution{fees: (Here, amount).into(), weight_limit: WeightLimit::Unlimited}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To execute XCM instructions, weight (some amount of resources) has to be bought. The amount of\nweight needed to execute an XCM depends on the number and type of instructions in the XCM. The\n",(0,i.jsx)(t.code,{children:"BuyExecution"})," instruction pays for the weight using the ",(0,i.jsx)(t.code,{children:"fees"}),". The ",(0,i.jsx)(t.code,{children:"fees"})," parameter describes the\nasset in the ",(0,i.jsx)(t.em,{children:"holding register"})," that should be used for paying for the weight. The ",(0,i.jsx)(t.code,{children:"weight_limit"}),"\nparameter defines the maximum amount of fees that can be used for buying weight. There are special\noccasions where it is not necessary to buy weight. See the chapter on\n",(0,i.jsx)(t.a,{href:"/docs/learn/xcm/fundamentals-fees",children:"weight and fees"})," for more information about the fees in XCM."]}),"\n",(0,i.jsx)(t.h3,{id:"depositasset",children:"DepositAsset"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-rust",children:"DepositAsset {\n    assets: All.into(),\n    beneficiary:  MultiLocation {\n        parents: 0,\n        interior: Junction::AccountId32 {\n            network: None,\n            id: BOB.clone().into()\n        }.into(),\n    }.into()\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The DepositAsset instruction is used to deposit funds from the holding register into the account of\nthe ",(0,i.jsx)(t.em,{children:"beneficiary"}),". We don\u2019t actually know how much is remaining in the holding register after the\n",(0,i.jsx)(t.code,{children:"BuyExecution"})," instruction, but that doesn\u2019t matter since we specify a wildcard for the asset(s)\nwhich should be deposited. In this case, the wildcard is ",(0,i.jsx)(t.code,{children:"All"}),", meaning that all assets in the\nholding register at that point in the execution should be deposited. The ",(0,i.jsx)(t.em,{children:"beneficiary"})," in this case\nis the account of Bob in the current consensus system."]}),"\n",(0,i.jsxs)(t.p,{children:["When the three instructions are combined, we withdraw ",(0,i.jsx)(t.code,{children:"amount"})," native tokens from the account of\nAlice, pay for the execution of these instructions, and deposit the remaining tokens in the account\nof Bob."]}),"\n",(0,i.jsx)(t.h2,{id:"what-next",children:"What next?"}),"\n",(0,i.jsxs)(t.p,{children:["Now that we have taken a first look at an XCM, we can dive deeper into all the XCM instructions, to\nbe able to build more complex XCVM programs. For an overview of the instructions check out the\n",(0,i.jsx)(t.a,{href:"https://github.com/paritytech/xcm-format#5-the-xcvm-instruction-set",children:"xcm-format repo"}),". We'll show\nexamples for every instruction in the ",(0,i.jsx)(t.a,{href:"/docs/learn/xcm/journey-summary",children:"journey through XCM"})," chapter. First,\nit's important to learn the fundamentals, ",(0,i.jsx)(t.code,{children:"MultiLocation"}),", ",(0,i.jsx)(t.code,{children:"MultiAsset"}),", and other concepts in XCM.\nWe'll talk about those next."]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var s=n(96540);const i={},o=s.createContext(i);function r(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);