"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3484],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),p=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return i.createElement(l.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=p(n),h=a,m=u["".concat(l,".").concat(h)]||u[h]||d[h]||o;return n?i.createElement(m,r(r({ref:t},c),{},{components:n})):i.createElement(m,r({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[u]="string"==typeof e?e:a,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},11213:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>p,toc:()=>u});var i=n(87462),a=n(63366),o=(n(67294),n(3905)),r=["components"],s={id:"learn-xcm-docs-config-deep-dive",title:"Executor Configuration",sidebar_label:"Executor Configuration",description:"Deep Dive into the Configuration of the XCM-Executor.",keywords:["xcm","cross-consensus messaging","config"],slug:"../config-deep-dive"},l="Executor Config",p={unversionedId:"learn/xcm/executor_config/learn-xcm-docs-config-deep-dive",id:"learn/xcm/executor_config/learn-xcm-docs-config-deep-dive",title:"Executor Configuration",description:"Deep Dive into the Configuration of the XCM-Executor.",source:"@site/../docs/learn/xcm/executor_config/config.md",sourceDirName:"learn/xcm/executor_config",slug:"/learn/xcm/config-deep-dive",permalink:"/docs/learn/xcm/config-deep-dive",draft:!1,editUrl:"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/xcm/executor_config/config.md",tags:[],version:"current",lastUpdatedBy:"gui",lastUpdatedAt:1712067554,formattedLastUpdatedAt:"Apr 2, 2024",frontMatter:{id:"learn-xcm-docs-config-deep-dive",title:"Executor Configuration",sidebar_label:"Executor Configuration",description:"Deep Dive into the Configuration of the XCM-Executor.",keywords:["xcm","cross-consensus messaging","config"],slug:"../config-deep-dive"},sidebar:"docs",previous:{title:"Channels and Bridges",permalink:"/docs/learn/xcm/journey-channels"},next:{title:"Testing",permalink:"/docs/learn/xcm/testing"}},c={},u=[{value:"XCM Executor Configuration",id:"xcm-executor-configuration",level:2},{value:"How to use multiple implementations.",id:"how-to-use-multiple-implementations",level:2},{value:"Config Items",id:"config-items",level:2},{value:"RuntimeCall",id:"runtimecall",level:3},{value:"XcmSender",id:"xcmsender",level:3},{value:"AssetTransactor",id:"assettransactor",level:3},{value:"OriginConverter",id:"originconverter",level:3},{value:"IsReserve",id:"isreserve",level:3},{value:"IsTeleporter",id:"isteleporter",level:3},{value:"UniversalLocation",id:"universallocation",level:3},{value:"Barrier",id:"barrier",level:3},{value:"Weigher",id:"weigher",level:3},{value:"Trader",id:"trader",level:3},{value:"ResponseHandler",id:"responsehandler",level:3},{value:"AssetTrap",id:"assettrap",level:3},{value:"AssetClaims",id:"assetclaims",level:3},{value:"AssetLocker",id:"assetlocker",level:3},{value:"AssetExchanger",id:"assetexchanger",level:3},{value:"SubscriptionService",id:"subscriptionservice",level:3},{value:"PalletInstancesInfo",id:"palletinstancesinfo",level:3},{value:"MaxAssetsIntoHolding",id:"maxassetsintoholding",level:3},{value:"FeeManager",id:"feemanager",level:3},{value:"MessageExporter",id:"messageexporter",level:3},{value:"UniversalAliases",id:"universalaliases",level:3},{value:"CallDispatcher",id:"calldispatcher",level:3},{value:"SafeCallFilter",id:"safecallfilter",level:3},{value:"What Next",id:"what-next",level:2}],d={toc:u},h="wrapper";function m(e){var t=e.components,n=(0,a.Z)(e,r);return(0,o.kt)(h,(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"executor-config"},"Executor Config"),(0,o.kt)("p",null,"As previously mentioned, the xcm-executor is a Cross-Consensus Virtual Machine (XCVM)\nimplementation. It provides an opinionated interpretation and execution of XCMs. Each chain that\nuses the xcm-executor, can configure it for their use case. In this chapter we will go over this\nconfiguration, explain each config item and give some examples of the tools and types that can be\nused to configure these items."),(0,o.kt)("h2",{id:"xcm-executor-configuration"},"XCM Executor Configuration"),(0,o.kt)("p",null,"Below we list the ",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/doc/xcm_executor/trait.Config.html"},"Config"),"\ntrait of the xcm-executor. The Config trait expects multiple associated types. Each type has a trait\nbound which the concrete type must implement. Some of these types will use a default implementation\nin most situations (e.g. RuntimeCall). Other types have a default implementation specified by the\nunit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()"),". Most types you'll want to carefully choose which implementation they get. For most\nof these types there are pre-defined solutions and building blocks you can use and adapt to your\nscenario. These solutions are listed in the xcm-builder\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/polkadot-sdk/tree/master/polkadot/xcm/xcm-builder/src"},"folder"),"."),(0,o.kt)("p",null,"We will now explain each type and go over some of the implementations of the type:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust,",metastring:"noplayground",noplayground:!0},"/// The trait to parameterize the `XcmExecutor`.\npub trait Config {\n    type RuntimeCall: Parameter + Dispatchable<PostInfo = PostDispatchInfo> + GetDispatchInfo;\n    type XcmSender: SendXcm;\n    type AssetTransactor: TransactAsset;\n    type OriginConverter: ConvertOrigin<<Self::RuntimeCall as Dispatchable>::RuntimeOrigin>;\n    type IsReserve: ContainsPair<MultiAsset, MultiLocation>;\n    type IsTeleporter: ContainsPair<MultiAsset, MultiLocation>;\n    type UniversalLocation: Get<InteriorMultiLocation>;\n    type Barrier: ShouldExecute;\n    type Weigher: WeightBounds<Self::RuntimeCall>;\n    type Trader: WeightTrader;\n    type ResponseHandler: OnResponse;\n    type AssetTrap: DropAssets;\n    type AssetClaims: ClaimAssets;\n    type AssetLocker: AssetLock;\n    type AssetExchanger: AssetExchange;\n    type SubscriptionService: VersionChangeNotifier;\n    type PalletInstancesInfo: PalletsInfoAccess;\n    type MaxAssetsIntoHolding: Get<u32>;\n    type FeeManager: FeeManager;\n    type MessageExporter: ExportXcm;\n    type UniversalAliases: Contains<(MultiLocation, Junction)>;\n    type CallDispatcher: CallDispatcher<Self::RuntimeCall>;\n    type SafeCallFilter: Contains<Self::RuntimeCall>;\n}\n")),(0,o.kt)("h2",{id:"how-to-use-multiple-implementations"},"How to use multiple implementations."),(0,o.kt)("p",null,"Some associated types in the Config trait are highly configurable and in certain cases will have\nmultiple implementations (e.g. Barrier). These implementations are then grouped using a tuple\n",(0,o.kt)("inlineCode",{parentName:"p"},"(impl_1, impl_2, ..., impl_n)"),". The execution of the tuple type is sequential, meaning that each\nitem is executed one after another. Each item is checked to see whether it fails to pass, then the\nnext item is checked, and so on. The execution is halted when one of these items returns positive\n(Ok or true, etc.). The next example of the Barrier type shows how the grouping works (understanding\neach item in the tuple is not necessary)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub type Barrier = (\n    TakeWeightCredit,\n    AllowTopLevelPaidExecutionFrom<Everything>,\n    AllowKnownQueryResponses<XcmPallet>,\n    AllowSubscriptionsFrom<Everything>,\n);\n\npub struct XcmConfig;\nimpl xcm_executor::Config for XcmConfig {\n    ...\n    type Barrier = Barrier;\n    ...\n}\n")),(0,o.kt)("p",null,"In the above example, when checking the barrier, we'll first check the TakeWeightCredit type. If it\nfails, we'll go on to check the ",(0,o.kt)("inlineCode",{parentName:"p"},"AllowTopLevelPaidExecutionFrom<Everything>")," and so on until one of\nthem gives a positive. If they all fail, a ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier")," error is thrown."),(0,o.kt)("h2",{id:"config-items"},"Config Items"),(0,o.kt)("p",null,"We now go over each config item to explain what the associate type does and how it is used in the\nxcm-executor. Many of these types have pre-defined solutions that can be found in the xcm-builder\nand a good way to understand these configurations is to look at example configurations. On the\nbottom of this page we listed some examples."),(0,o.kt)("h3",{id:"runtimecall"},"RuntimeCall"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeCall")," type is equal to the RuntimeCall created in the ",(0,o.kt)("inlineCode",{parentName:"p"},"construct_runtime!")," macro. It is\nan enum of all the callable functions of each of the implemented pallets."),(0,o.kt)("h3",{id:"xcmsender"},"XcmSender"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"XcmSender")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"SendXcm")," trait, and defines how the xcm_executor can send XCMs\n(which transport layer it can use for the XCMs). This type normally implements a tuple for one or\nmore ",(0,o.kt)("a",{parentName:"p",href:"https://wiki.polkadot.network/docs/learn-xcm-transport"},"transport layer(s)"),". For example a\nparachain can implement the XcmSender as:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"}," (\n    // Two routers - use UMP to communicate with the relay chain:\n    cumulus_primitives_utility::ParentAsUmp<ParachainSystem, PolkadotXcm, ()>,\n    // ..and XCMP to communicate with the sibling chains.\n    XcmpQueue,\n);\n")),(0,o.kt)("p",null,"If a runtime does not contain the XcmpQueue pallet as a config item for XcmSender, it will not be\nable to send messages to other parachains. This can be useful for controlling the destinations that\nan XCM can be sent to."),(0,o.kt)("h3",{id:"assettransactor"},"AssetTransactor"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetTransactor")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"TransactAsset")," trait and defines how the xcm-executor can\nconvert ",(0,o.kt)("inlineCode",{parentName:"p"},"MultiAsset"),"s from and to on chain assets and how to transfer these assets between accounts,\nor from and to the holding register. As chains can support different types of currencies (native\ntokens), fungibles and non-fungibles, we can configure the AssetTransactor in different ways,\ndepending on the chains implementation fo these types. Three default implementations are provided in\nthe xcm-builder, namely the ",(0,o.kt)("inlineCode",{parentName:"p"},"CurrencyAdapter"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"FungiblesAdapter")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"NonFungiblesAdapter"),"."),(0,o.kt)("h3",{id:"originconverter"},"OriginConverter"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"OriginConverter")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"ConvertOrigin")," trait and defines how the xcm-executor can\nconvert a ",(0,o.kt)("inlineCode",{parentName:"p"},"MultiLocation")," into a ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeOrigin"),". Most xcm-executors take multiple implementations\nin a tuple for this configuration as there are many different MLs we would like to convert. When\nmultiple ",(0,o.kt)("inlineCode",{parentName:"p"},"OriginConverter"),"s conflict, the\n",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/doc/xcm/v2/enum.OriginKind.html"},"OriginKind")," that is passed\nto the ",(0,o.kt)("inlineCode",{parentName:"p"},"convert_origin")," function is used to distingues which ",(0,o.kt)("inlineCode",{parentName:"p"},"OriginConverter")," to use. There are\nfour different ",(0,o.kt)("inlineCode",{parentName:"p"},"OriginKind"),"s :"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub enum OriginKind {\n    Native,\n    SovereignAccount,\n    Superuser,\n    Xcm,\n}\n")),(0,o.kt)("p",null,"An example of the use of ",(0,o.kt)("inlineCode",{parentName:"p"},"OriginKind"),"s are the ",(0,o.kt)("inlineCode",{parentName:"p"},"SovereignSignedViaLocation")," and\n",(0,o.kt)("inlineCode",{parentName:"p"},"SignedAccountId32AsNative")," OriginConverters (defined in xcm-builder). The first converts an\nsovereign account into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Signed")," RuntimeOrigin (uses ",(0,o.kt)("inlineCode",{parentName:"p"},"SovereignAccount")," OriginKind) while the\nsecond converts a local native account into a ",(0,o.kt)("inlineCode",{parentName:"p"},"Signed")," RuntimeOrigin (uses ",(0,o.kt)("inlineCode",{parentName:"p"},"Native")," OriginKind)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"pub type SovereignAccountOf = AccountId32Aliases<ThisNetwork, AccountId>;\n(\n    // A `Signed` origin of the sovereign account that the original location controls.\n    SovereignSignedViaLocation<SovereignAccountOf, RuntimeOrigin>,\n    // The AccountId32 location type can be expressed natively as a `Signed` origin.\n    SignedAccountId32AsNative<ThisNetwork, RuntimeOrigin>,\n);\n\n")),(0,o.kt)("h3",{id:"isreserve"},"IsReserve"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IsReserve")," type must be set to specify which ",(0,o.kt)("inlineCode",{parentName:"p"},"<MultiAsset, MultiLocation>")," pair we trust to\ndeposit reserve assets on our chain. We can also use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," to block\n",(0,o.kt)("inlineCode",{parentName:"p"},"ReserveAssetDeposited")," instructions. An example implementation is the ",(0,o.kt)("inlineCode",{parentName:"p"},"NativeAsset")," struct, that\naccepts an asset iff it is a native asset."),(0,o.kt)("h3",{id:"isteleporter"},"IsTeleporter"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"IsTeleporter")," type must be set to specify which ",(0,o.kt)("inlineCode",{parentName:"p"},"<MultiAsset, MultiLocation>")," pair we trust to\nteleport assets to our chain. We can also use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," to block ",(0,o.kt)("inlineCode",{parentName:"p"},"ReceiveTeleportedAssets"),"\ninstruction. An example implementation is the ",(0,o.kt)("inlineCode",{parentName:"p"},"NativeAsset")," struct, that accepts an asset iff it is\na native asset."),(0,o.kt)("h3",{id:"universallocation"},"UniversalLocation"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalLocation")," type describes the location of the runtime implementing the xcm-executor in\nthe consensus universe. Below we give some examples of ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalLocation")," implementations."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"//Polkadot\nX1(GlobalConsensus(NetworkId::Polkadot))\n//Kusama\nX1(GlobalConsensus(NetworkId::Kusama))\n//Statemint\nX2(GlobalConsensus(NetworkId::Polkadot), Parachain(1000))\n")),(0,o.kt)("h3",{id:"barrier"},"Barrier"),(0,o.kt)("p",null,"Before any XCMs are executed in the XCM executor, they need to pass the ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier"),"\ntype implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"ShouldExecute")," trait and can be seen as the firewall of the xcm-executor. Each\ntime the xcm-executor receives an XCM, it check with the barrier if the XCM should be executed. We\ncan also define multiple barriers for our ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier")," type by using a tuple. During execution, each\nbarrier is checks, and if one of them succeed, the XCM is executed. Example of a ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier"),"\nimplementations is ",(0,o.kt)("inlineCode",{parentName:"p"},"AllowTopLevelPaidExecutionFrom<T>")," that accepts the XCM if the ",(0,o.kt)("inlineCode",{parentName:"p"},"T")," contains the\norigin of the XCM and the XCM contains the ",(0,o.kt)("inlineCode",{parentName:"p"},"BuyExecution")," instruction. To accept all XCMs that pay\nfor execution we could set the barrier to ",(0,o.kt)("inlineCode",{parentName:"p"},"AllowTopLevelPaidExecutionFrom<Everything>"),". There are\nmultiple pre-defined barrier implementations in the xcm-builder."),(0,o.kt)("h3",{id:"weigher"},"Weigher"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Weigher")," is responsible for weighing full XCMs and individual instructions. This weight is\ncalculated before the XCM execution, and this calculated weight is checked against the weight_limit.\nIf the weight is more than weight_limit, the xcm will not be executed. The weight is also passed to\neach ",(0,o.kt)("inlineCode",{parentName:"p"},"Barrier"),", as certain barriers execute weight-based checks. After the execution of the XCM,\nunused weight is refunded (if possible). There are pre-defined ",(0,o.kt)("inlineCode",{parentName:"p"},"Weigher")," solutions in the\nxcm-builder. The most used is the ",(0,o.kt)("inlineCode",{parentName:"p"},"FixedWeightBounds"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},"// BaseXcmWeight is a const weight.\nFixedWeightBounds<BaseXcmWeight, RuntimeCall, MaxInstructions>;\n")),(0,o.kt)("p",null,"Note: ",(0,o.kt)("a",{parentName:"p",href:"/docs/learn/xcm/fundamentals-fees"},"More information")," about weight."),(0,o.kt)("h3",{id:"trader"},"Trader"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Trader")," type is responsible for buying weight in the ",(0,o.kt)("inlineCode",{parentName:"p"},"BuyExecution")," instruction using assets in\nthe holding register and to refund unspend weight. One of the first implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"Trader"),"\nis defined in the xcm-builder, namely the ",(0,o.kt)("inlineCode",{parentName:"p"},"UsingComponents")," trader."),(0,o.kt)("h3",{id:"responsehandler"},"ResponseHandler"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"ResponseHandler")," type is responsible for handling the ",(0,o.kt)("inlineCode",{parentName:"p"},"QueryResponse")," instructions. A\n",(0,o.kt)("inlineCode",{parentName:"p"},"ResponseHandler")," implementation has to implement the ",(0,o.kt)("inlineCode",{parentName:"p"},"OnResponse")," trait. One of the implementations\nof the ",(0,o.kt)("inlineCode",{parentName:"p"},"ResponseHandler")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"pallet-xcm"),". This will be the main implementation for most\nFRAME-based systems that implement the XCM-executor. Another option is to use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if\nyou do not want to support ",(0,o.kt)("inlineCode",{parentName:"p"},"QueryResponse"),"."),(0,o.kt)("h3",{id:"assettrap"},"AssetTrap"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetTrap")," type is responsible for handling the funds left over in holding after the execution\nof the XCM. The assets are stored in the AssetTrap and can be claimed using the ClaimAsset\ninstruction. One of the implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetTrap")," type is the ",(0,o.kt)("inlineCode",{parentName:"p"},"pallet-xcm"),". Another option\nis to use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if you do not want to support asset trapping. In this case, the assets\nthat are left in holding are burned."),(0,o.kt)("h3",{id:"assetclaims"},"AssetClaims"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetClaims")," type is responsible for claiming trapped assets. It is during execution of the\n",(0,o.kt)("inlineCode",{parentName:"p"},"ClaimAsset")," instruction. One of the implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetClaims")," type is the ",(0,o.kt)("inlineCode",{parentName:"p"},"pallet-xcm"),".\nAnother option is to use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if you do not want to support asset claiming."),(0,o.kt)("h3",{id:"assetlocker"},"AssetLocker"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetLocker")," type is responsible with handling locking and unlocking assets. One of the\nimplementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetLocker")," type is the ",(0,o.kt)("inlineCode",{parentName:"p"},"pallet-xcm"),". Another option is to use the unit\ntype ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if you do not want to support asset locking."),(0,o.kt)("h3",{id:"assetexchanger"},"AssetExchanger"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetExchanger")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"AssetExchange")," trait and handles the exchange of assets\nfor the ExchangeAsset instruction. An option is to use the unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," if you do not want to\nsupport asset exchanging."),(0,o.kt)("h3",{id:"subscriptionservice"},"SubscriptionService"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"VersionChangeNotifier")," trait and is used for the\nexecution of the (Un)SubscribeVersion instructions. When a chain receives the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscribeVersion"),"\ninstruction, the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," should send back a ",(0,o.kt)("inlineCode",{parentName:"p"},"QueryResponse")," with the XCM version that\nthe chain uses. One of the implementations of the ",(0,o.kt)("inlineCode",{parentName:"p"},"SubscriptionService")," is the ",(0,o.kt)("inlineCode",{parentName:"p"},"pallet-xcm"),". This\nwill be the main implementation for most FRAME-based systems that implement the XCM-executor."),(0,o.kt)("h3",{id:"palletinstancesinfo"},"PalletInstancesInfo"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"PalletInstancesInfo")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"PalletsInfoAccess")," trait and is used in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"QueryPallet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"ExpectPallet")," instructions. It supplies the information of all the pallets in the\nRuntime, and is therefore FRAME specific. The unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," can be used if you do not want to\nsupport pallet information."),(0,o.kt)("h3",{id:"maxassetsintoholding"},"MaxAssetsIntoHolding"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MaxAssetsIntoHolding")," type is used to set a limit on the number of assets in the Holding\nRegister. In the worse case, the Holding Register may contain up to twice as many assets as this\nlimit."),(0,o.kt)("h3",{id:"feemanager"},"FeeManager"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"FeeManager")," type is used to manage what happens with the fees that need to be paid for certain\nXCM instructions. A ",(0,o.kt)("inlineCode",{parentName:"p"},"FeeManager")," implementation implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"FeeManager")," trait. The FeeManager\ndetermines if fees should be paid (or if they are waived) and what to do with the paid fees. The\nunit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," can be used if you want to waive every fee."),(0,o.kt)("h3",{id:"messageexporter"},"MessageExporter"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"MessageExporter")," type implements the ",(0,o.kt)("inlineCode",{parentName:"p"},"ExportXcm")," trait and is used to export a message to\nanother consensus system. The ",(0,o.kt)("inlineCode",{parentName:"p"},"MessageExporter")," is different from the ",(0,o.kt)("inlineCode",{parentName:"p"},"XcmSender"),". The\n",(0,o.kt)("inlineCode",{parentName:"p"},"MessageExporter")," is able to spoof the origin of the message, meaning it can represent a different\norigin then the local (i.e. the caller chain's) location. The MessageExporter will mainly be used to\nsend XCMs over bridges. For a more in depth explanation, see the\n",(0,o.kt)("a",{parentName:"p",href:"https://paritytech.github.io/polkadot/doc/xcm_executor/traits/trait.ExportXcm.html"},"ExportXcm trait"),".\nThe unit type ",(0,o.kt)("inlineCode",{parentName:"p"},"()")," can be used if you do not want to support XCM exporting."),(0,o.kt)("h3",{id:"universalaliases"},"UniversalAliases"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalAliases")," type is used to list the origin locations and specific universal junctions to\nwhich they are allowed to elevate themselves. ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalAliases")," is used in the ",(0,o.kt)("inlineCode",{parentName:"p"},"UniversalOrigin"),"\ninstruction. To not allow any alliasing of origins, ",(0,o.kt)("inlineCode",{parentName:"p"},"Nothing")," can be used."),(0,o.kt)("h3",{id:"calldispatcher"},"CallDispatcher"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"CallDispatcher")," type is used by xcm-executor to dispatch calls that are passed in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Transact")," instruction with the given origin. When no special call dispatcher is required, this can\nbe set to the same type as ",(0,o.kt)("inlineCode",{parentName:"p"},"RuntimeCall"),". However, ",(0,o.kt)("inlineCode",{parentName:"p"},"CallDispatcher")," can be used to customize call\ndispatch, such as adapting the origin based on the call or modifying the call."),(0,o.kt)("h3",{id:"safecallfilter"},"SafeCallFilter"),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"SafeCallFilter")," type is used by the xcm-executor to whitelist calls that can be made in the\n",(0,o.kt)("inlineCode",{parentName:"p"},"Transact")," instruction. This is a temporary measure until proof size weights for XCM instructions\nare properly account for. If you want to allow all calls in ",(0,o.kt)("inlineCode",{parentName:"p"},"Tansact"),", use ",(0,o.kt)("inlineCode",{parentName:"p"},"Everything"),"."),(0,o.kt)("h2",{id:"what-next"},"What Next"),(0,o.kt)("p",null,"Check out the\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/polkadot-fellows/runtimes/blob/main/relay/kusama/src/xcm_config.rs"},"Kusama"),",\n",(0,o.kt)("a",{parentName:"p",href:"https://github.com/polkadot-fellows/runtimes/blob/main/system-parachains/asset-hubs/asset-hub-kusama/src/xcm_config.rs"},"Statemine"),",\nor ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/paritytech/trappist/blob/main/runtime/trappist/src/xcm_config.rs"},"Trappist"),"\nfor examples of how to implement the xcm-executor config."))}m.isMDXComponent=!0}}]);