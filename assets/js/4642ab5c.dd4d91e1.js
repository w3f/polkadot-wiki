"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4434],{23213:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>a,default:()=>c,frontMatter:()=>o,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"learn/learn-cryptography","title":"Cryptography on Polkadot","description":"Cryptographic Functions used in Polkadot.","source":"@site/../docs/learn/learn-cryptography.md","sourceDirName":"learn","slug":"/learn-cryptography","permalink":"/docs/learn-cryptography","draft":false,"unlisted":false,"editUrl":"https://github.com/w3f/polkadot-wiki/edit/master/docs/learn/learn-cryptography.md","tags":[],"version":"current","lastUpdatedBy":"Filippo","lastUpdatedAt":1726760224000,"frontMatter":{"id":"learn-cryptography","title":"Cryptography on Polkadot","sidebar_label":"Cryptography","description":"Cryptographic Functions used in Polkadot.","keywords":["cryptography","hashing","keypair","signing","keys","randomness","verifiable random function","VDF"],"slug":"../learn-cryptography"},"sidebar":"docs","previous":{"title":"NFT Pallets","permalink":"/docs/learn-nft-pallets"},"next":{"title":"NPoS Election Algorithms","permalink":"/docs/learn-phragmen"}}');var r=s(74848),i=s(28453);const o={id:"learn-cryptography",title:"Cryptography on Polkadot",sidebar_label:"Cryptography",description:"Cryptographic Functions used in Polkadot.",keywords:["cryptography","hashing","keypair","signing","keys","randomness","verifiable random function","VDF"],slug:"../learn-cryptography"},a=void 0,h={},l=[{value:"Hashing Algorithm",id:"hashing-algorithm",level:2},{value:"Keypairs and Signing",id:"keypairs-and-signing",level:2},{value:"Keys",id:"keys",level:2},{value:"Account Keys",id:"account-keys",level:3},{value:"Stash and Staking Proxy Keys",id:"stash-and-staking-proxy-keys",level:3},{value:"Session Keys",id:"session-keys",level:3},{value:"FAQ about Keys",id:"faq-about-keys",level:3},{value:"Why was <code>ed25519</code> selected over <code>secp256k1</code>?",id:"why-was-ed25519-selected-over-secp256k1",level:4},{value:"What is <code>sr25519</code> and where did it come from?",id:"what-is-sr25519-and-where-did-it-come-from",level:4},{value:"Are BLS signatures used in Polkadot?",id:"are-bls-signatures-used-in-polkadot",level:4},{value:"Randomness",id:"randomness",level:2},{value:"VRF",id:"vrf",level:3},{value:"Here&#39;s how it works in detail:",id:"heres-how-it-works-in-detail",level:4},{value:"RANDAO",id:"randao",level:3},{value:"VDFs",id:"vdfs",level:3},{value:"Resources",id:"resources",level:2},{value:"Appendix A: On the security of curves",id:"appendix-a-on-the-security-of-curves",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"This is a high-level overview of the cryptography used in Polkadot. It assumes that you have some\nknowledge about cryptographic primitives that are generally used in blockchains such as hashes,\nelliptic curve cryptography (ECC), and public-private keypairs."}),"\n",(0,r.jsxs)(n.p,{children:["For detailed descriptions on the cryptography used in Polkadot please see the more advanced\n",(0,r.jsx)(n.a,{href:"https://research.web3.foundation",children:"research wiki"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"hashing-algorithm",children:"Hashing Algorithm"}),"\n",(0,r.jsxs)(n.p,{children:["The hashing algorithm used in Polkadot is\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/BLAKE_(hash_function)#BLAKE2",children:"Blake2b"}),". Blake2 is considered to be\na very fast cryptographic hash function that is also used in the cryptocurrency\n",(0,r.jsx)(n.a,{href:"https://z.cash",children:"Zcash"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"keypairs-and-signing",children:"Keypairs and Signing"}),"\n",(0,r.jsx)(n.p,{children:'Polkadot uses Schnorrkel/Ristretto x25519 ("sr25519") as its key derivation and signing algorithm.'}),"\n",(0,r.jsxs)(n.p,{children:["Sr25519 is based on the same underlying ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Curve25519",children:"Curve25519"})," as\nits EdDSA counterpart, ",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/EdDSA#Ed25519",children:"Ed25519"}),". However, it uses\nSchnorr signatures instead of the EdDSA scheme. Schnorr signatures bring some noticeable benefits\nover the ECDSA/EdDSA schemes. For one, it is more efficient and still retains the same feature set\nand security assumptions. Additionally, it allows for native multisignature through\n",(0,r.jsx)(n.a,{href:"https://bitcoincore.org/en/2017/03/23/schnorr-signature-aggregation/",children:"signature aggregation"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The names Schnorrkel and Ristretto come from the two Rust libraries that implement this scheme, the\n",(0,r.jsx)(n.a,{href:"https://github.com/w3f/schnorrkel",children:"Schnorrkel"})," library for Schnorr signatures and the\n",(0,r.jsx)(n.a,{href:"https://ristretto.group/ristretto.html",children:"Ristretto"})," library that makes it possible to use cofactor-8\ncurves like Curve25519."]}),"\n",(0,r.jsx)(n.h2,{id:"keys",children:"Keys"}),"\n",(0,r.jsx)(n.p,{children:"Public and private keys are an important aspect of most crypto-systems and an essential component\nthat enables blockchains like Polkadot to exist."}),"\n",(0,r.jsx)(n.h3,{id:"account-keys",children:"Account Keys"}),"\n",(0,r.jsx)(n.p,{children:"Account keys are keys that are meant to control funds. They can be either:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The vanilla ",(0,r.jsx)(n.code,{children:"ed25519"})," implementation using Schnorr signatures."]}),"\n",(0,r.jsxs)(n.li,{children:["The Schnorrkel/Ristretto ",(0,r.jsx)(n.code,{children:"sr25519"})," variant using Schnorr signatures."]}),"\n",(0,r.jsx)(n.li,{children:"ECDSA signatures on secp256k1"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["There are no differences in security between ",(0,r.jsx)(n.code,{children:"ed25519"})," and ",(0,r.jsx)(n.code,{children:"sr25519"})," for simple signatures. We\nexpect ",(0,r.jsx)(n.code,{children:"ed25519"})," to be much better supported by commercial HSMs for the foreseeable future. At the\nsame time, ",(0,r.jsx)(n.code,{children:"sr25519"})," makes implementing more complex protocols safer. In particular, ",(0,r.jsx)(n.code,{children:"sr25519"})," comes\nwith safer version of many protocols like HDKD common in the Bitcoin and Ethereum ecosystem."]}),"\n",(0,r.jsx)(n.h3,{id:"stash-and-staking-proxy-keys",children:"Stash and Staking Proxy Keys"}),"\n",(0,r.jsx)(n.p,{children:"When we talk about stash and staking proxy keys, we usually talk about them in the context of\nrunning a validator or nominating, but they are useful concepts for all users to know. Both keys are\ntypes of account keys. They are distinguished by their intended use, not by an underlying\ncryptographic difference. All the info mentioned in the parent section applies to these keys. When\ncreating new staking proxy or stash keys, all cryptography supported by account keys are an\navailable option."}),"\n",(0,r.jsx)(n.p,{children:"The staking proxy key is a semi-online key that will be in the direct control of a user, and used to\nsubmit manual extrinsics. For validators or nominators, this means that the proxy key will be used\nto start or stop validating or nominating. Proxy keys should hold some native tokens to pay for\nfees, but they should not be used to hold huge amounts or life savings. Since they will be exposed\nto the internet with relative frequency, they should be treated carefully and occasionally replaced\nwith new ones."}),"\n",(0,r.jsx)(n.p,{children:"The stash key is a key that will, in most cases, be a cold wallet, existing on a piece of paper in a\nsafe or protected by layers of hardware security. It should rarely, if ever, be exposed to the\ninternet or used to submit extrinsics. The stash key is intended to hold a large amount of funds. It\nshould be thought of as a saving's account at a bank, which ideally is only ever touched in urgent\nconditions. Or, perhaps a more apt metaphor is to think of it as buried treasure, hidden on some\nrandom island and only known by the pirate who originally hid it."}),"\n",(0,r.jsxs)(n.p,{children:["Since the stash key is kept offline, it must be set to have its funds bonded to a particular staking\nproxy. For non-spending actions, the staking proxy has the funds of the stash behind it. For\nexample, in nominating, staking, or voting, the proxy can indicate its preference with the weight of\nthe stash. It will never be able to actually move or claim the funds in the stash key. However, if\nsomeone does obtain your proxy key, they could use it for ",(0,r.jsx)(n.a,{href:"/docs/learn-offenses",children:"slashable behavior"}),",\nso you should still protect it and change it regularly."]}),"\n",(0,r.jsx)(n.h3,{id:"session-keys",children:"Session Keys"}),"\n",(0,r.jsxs)(n.p,{children:["Session keys are hot keys that must be kept online by a validator to perform network operations.\nSession keys are typically generated in the client, although they don't have to be. They are ",(0,r.jsx)(n.em,{children:"not"}),"\nmeant to control funds and should only be used for their intended purpose. They can be changed\nregularly; your staking proxy only need to create a certificate by signing a session public key and\nbroadcast this certificate via an extrinsic."]}),"\n",(0,r.jsx)(n.p,{children:"Polkadot uses six session keys:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Authority Discovery: sr25519"}),"\n",(0,r.jsx)(n.li,{children:"BABE: sr25519"}),"\n",(0,r.jsx)(n.li,{children:"BEEFY: ecdsa"}),"\n",(0,r.jsx)(n.li,{children:"GRANDPA: ed25519"}),"\n",(0,r.jsx)(n.li,{children:"Parachain Assignment: sr25519"}),"\n",(0,r.jsx)(n.li,{children:"Parachain Validator: ed25519"}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["BABE requires keys suitable for use in a ",(0,r.jsx)(n.a,{href:"#vrf",children:"Verifiable Random Function"})," as well as for digital\nsignatures. Sr25519 keys have both capabilities and so are used for BABE."]}),"\n",(0,r.jsx)(n.p,{children:"In the future, we plan to use a BLS key for GRANDPA because it allows for more efficient signature\naggregation."}),"\n",(0,r.jsx)(n.h3,{id:"faq-about-keys",children:"FAQ about Keys"}),"\n",(0,r.jsxs)(n.h4,{id:"why-was-ed25519-selected-over-secp256k1",children:["Why was ",(0,r.jsx)(n.code,{children:"ed25519"})," selected over ",(0,r.jsx)(n.code,{children:"secp256k1"}),"?"]}),"\n",(0,r.jsxs)(n.p,{children:["The original key derivation cryptography that was implemented for Polkadot and Substrate chains was\n",(0,r.jsx)(n.code,{children:"ed25519"}),", which is a Schnorr signature algorithm implemented over the Edward's Curve 25519 (so\nnamed due to the parameters of the curve equation)."]}),"\n",(0,r.jsxs)(n.p,{children:["Most cryptocurrencies, including Bitcoin and Ethereum, currently use ECDSA signatures on the\nsecp256k1 curve. This curve is considered much more secure than NIST curves, which\n",(0,r.jsx)(n.a,{href:"#appendix-a-on-the-security-of-curves",children:"have possible backdoors from the NSA"}),". The Curve25519 is\nconsidered possibly ",(0,r.jsx)(n.em,{children:"even more"})," secure than this one and allows for easier implementation of Schnorr\nsignatures. A recent patent expiration on it has made it the preferred choice for use in Polkadot."]}),"\n",(0,r.jsxs)(n.p,{children:["The choice of using Schnorr signatures over using ECDSA is not so cut and dried. Jeff Burdges (a\nWeb3 researcher) provides additional details on the decision in this\n",(0,r.jsx)(n.a,{href:"https://research.web3.foundation/Polkadot/security/keys",children:"research post"})," on the topic:"]}),"\n",(0,r.jsx)(n.admonition,{title:"Choosing Schnorr signatures over ECDSA signatures",type:"info",children:(0,r.jsx)(n.p,{children:"There is one sacrifice we make by choosing Schnorr signatures over ECDSA signatures for account\nkeys: Both require 64 bytes, but only ECDSA signatures communicate their public key. There are\nobsolete Schnorr variants that support recovering the public key from a signature, but they break\nimportant functionality like hierarchical deterministic key derivation. In consequence, Schnorr\nsignatures often take an extra 32 bytes for the public key."})}),"\n",(0,r.jsx)(n.p,{children:"But ultimately the benefits of using Schnorr signatures outweigh the tradeoffs, and future\noptimizations may resolve the inefficiencies pointed out in the quote above."}),"\n",(0,r.jsxs)(n.h4,{id:"what-is-sr25519-and-where-did-it-come-from",children:["What is ",(0,r.jsx)(n.code,{children:"sr25519"})," and where did it come from?"]}),"\n",(0,r.jsxs)(n.p,{children:["Some context: The Schnorr signatures over the Twisted Edward's Curve25519 are considered secure,\nhowever Ed25519 has not been completely devoid of its bugs. Most notably,\n",(0,r.jsx)(n.a,{href:"https://www.getmonero.org/2017/05/17/disclosure-of-a-major-bug-in-cryptonote-based-currencies.html",children:"Monero and all other CryptoNote currencies"}),"\nwere vulnerable to a double spend exploit that could have potentially led to undetected, infinite\ninflation."]}),"\n",(0,r.jsx)(n.p,{children:"These exploits were due to one peculiarity in Ed25519, which is known as its cofactor of 8. The\ncofactor of a curve is an esoteric detail that could have dire consequences for the security of\nimplementation of more complex protocols."}),"\n",(0,r.jsxs)(n.p,{children:["Conveniently, ",(0,r.jsx)(n.a,{href:"https://www.shiftleft.org/papers/decaf/index.xhtml",children:"Mike Hamburg's Decaf paper"}),"\nprovides a possible path forward to solving this potential bug. Decaf is basically a way to take\nTwisted Edward's Curves cofactor and mathematically change it with little cost to performance and\ngains to security."]}),"\n",(0,r.jsxs)(n.p,{children:["The Decaf paper approach by the ",(0,r.jsx)(n.a,{href:"https://ristretto.group/",children:"Ristretto Group"})," was extended and\nimplemented in Rust to include cofactor-8 curves like the Curve25519 and makes Schnorr signatures\nover the Edward's curve more secure."]}),"\n",(0,r.jsxs)(n.p,{children:["Web3 Foundation has implemented a Schnorr signature library using the more secure Ristretto\ncompression over the Curve25519 in the ",(0,r.jsx)(n.a,{href:"https://github.com/w3f/schnorrkel",children:"Schnorrkel"})," repository.\nSchnorrkel implements related protocols on top of this curve compression such as HDKD, MuSig, and a\nverifiable random function (VRF). It also includes various minor improvements such as the hashing\nscheme STROBE that can theoretically process huge amounts of data with only one call across the Wasm\nboundary."]}),"\n",(0,r.jsxs)(n.p,{children:["The implementation of Schnorr signatures that is used in Polkadot and implements the Schnorrkel\nprotocols over the Ristretto compression of the Curve25519 is known as ",(0,r.jsx)(n.strong,{children:"sr25519"}),"."]}),"\n",(0,r.jsx)(n.h4,{id:"are-bls-signatures-used-in-polkadot",children:"Are BLS signatures used in Polkadot?"}),"\n",(0,r.jsx)(n.p,{children:"Not yet, but they will be. BLS signatures allow more efficient signature aggregation. Because\nGRANDPA validators are usually signing the same thing (e.g. a block), it makes sense to aggregate\nthem, which can allow for other protocol optimizations."}),"\n",(0,r.jsx)(n.admonition,{title:"From the BLS library's README",type:"info",children:(0,r.jsx)(n.p,{children:"Boneh-Lynn-Shacham (BLS) signatures have slow signing, very slow verification, require slow and much\nless secure pairing friendly curves, and tend towards dangerous malleability. Yet, BLS permits a\ndiverse array of signature aggregation options far beyond any other known signature scheme, which\nmakes BLS a preferred scheme for voting in consensus algorithms and for threshold signatures."})}),"\n",(0,r.jsx)(n.p,{children:"Even though Schnorr signatures allow for signature aggregation, BLS signatures are much more\nefficient in some fashions. For this reason it will be one of the session keys that will be used by\nvalidators on the Polkadot network and critical to the GRANDPA finality gadget."}),"\n",(0,r.jsx)(n.h2,{id:"randomness",children:"Randomness"}),"\n",(0,r.jsxs)(n.p,{children:["Randomness in Proof of Stake blockchains is important for a fair and unpredictable distribution of\nvalidator responsibilities. Computers are bad at random numbers because they are deterministic\ndevices (the same input always produces the same output). What people usually call random numbers on\na computer (such as in a gaming application), are ",(0,r.jsx)(n.em,{children:"pseudo-random"})," - that is, they depend on a\nsufficiently random ",(0,r.jsx)(n.em,{children:"seed"})," provided by the user or another type of ",(0,r.jsx)(n.em,{children:"oracle"}),", like a\n",(0,r.jsx)(n.a,{href:"https://www.random.org/randomness/",children:"weather station for atmospheric noise"}),", your\n",(0,r.jsx)(n.a,{href:"https://mdpi.altmetric.com/details/47574324",children:"heart rate"}),", or even\n",(0,r.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Lavarand",children:"lava lamps"}),", from which it can generate a series of\nseemingly-random numbers. But given the same seed, the same sequence will always be generated."]}),"\n",(0,r.jsx)(n.p,{children:"Though, these inputs will vary based on time and space, and it would be impossible to get the same\nresult into all the nodes of a particular blockchain around the world. If nodes get different inputs\non which to build blocks, forks happen. Real-world entropy is not suitable for use as a seed for\nblockchain randomness."}),"\n",(0,r.jsxs)(n.p,{children:["There are two main approaches to blockchain randomness in production today: ",(0,r.jsx)(n.code,{children:"RANDAO"})," and ",(0,r.jsx)(n.code,{children:"VRF"}),".\nPolkadot uses VRF."]}),"\n",(0,r.jsx)(n.h3,{id:"vrf",children:"VRF"}),"\n",(0,r.jsx)(n.p,{children:"A verifiable random function (VRF) is a mathematical operation that takes some input and produces a\nrandom number along with a proof of authenticity that this random number was generated by the\nsubmitter. The proof can be verified by any challenger to ensure the random number generation is\nvalid."}),"\n",(0,r.jsxs)(n.p,{children:["The VRF used in Polkadot is roughly the same as the one used in Ouroboros Praos. Ouroboros\nrandomness is secure for block production and works well for ",(0,r.jsx)(n.a,{href:"/docs/learn-consensus#BABE",children:"BABE"}),". Where\nthey differ is that Polkadot's VRF does not depend on a central clock (the problem becomes - whose\ncentral clock?), rather, it depends on its own past results to determine present and future results,\nand it uses slot numbers as a clock emulator, estimating time."]}),"\n",(0,r.jsx)(n.h4,{id:"heres-how-it-works-in-detail",children:"Here's how it works in detail:"}),"\n",(0,r.jsxs)(n.p,{children:["Slots are discrete units of time six seconds in length. Each slot can contain a block, but may not.\nSlots make up ",(0,r.jsx)(n.a,{href:"/docs/glossary##epoch",children:"epochs"})," - on Polkadot, 2400 slots make one epoch,\nwhich makes epochs four hours long."]}),"\n",(0,r.jsx)(n.p,{children:'In every slot, each validator "rolls a die". They execute a function (the VRF) that takes as input\nthe following:'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:'The "secret key",'})," a key specifically made for these die rolls."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"An epoch randomness value,"})," which is the hash of VRF values from the blocks in the epoch before\nlast (N-2), so past randomness affects the current pending randomness (N)."]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.strong,{children:"The slot number."})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.img,{alt:"VRF_babe",src:s(64281).A+"",width:"1685",height:"564"})}),"\n",(0,r.jsxs)(n.p,{children:["The output is two values: a ",(0,r.jsx)(n.code,{children:"RESULT"})," (the random value) and a ",(0,r.jsx)(n.code,{children:"PROOF"})," (a proof that the random value\nwas generated correctly)."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"RESULT"})," is then compared to a ",(0,r.jsx)(n.em,{children:"threshold"})," defined in the implementation of the protocol\n(specifically, in the Polkadot Host). If the value is less than the threshold, then the validator\nwho rolled this number is a viable block production candidate for that slot. The validator then\nattempts to create a block and submits this block into the network along with the previously\nobtained ",(0,r.jsx)(n.code,{children:"PROOF"})," and ",(0,r.jsx)(n.code,{children:"RESULT"}),". Under VRF, every validator rolls a number for themselves, checks it\nagainst a threshold, and produces a block if the random roll is under that threshold."]}),"\n",(0,r.jsxs)(n.p,{children:["The astute reader will notice that due to the way this works, some slots may have no validators as\nblock producer candidates because all validator candidates rolled too high and missed the threshold.\nWe clarify how we resolve this issue and make sure that Polkadot block times remain near\nconstant-time in the wiki page on ",(0,r.jsx)(n.a,{href:"/docs/learn-consensus",children:"consensus"}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"randao",children:"RANDAO"}),"\n",(0,r.jsxs)(n.p,{children:["An alternative method for getting randomness on-chain is the\n",(0,r.jsx)(n.a,{href:"https://github.com/randao/randao",children:"RANDAO"})," method from Ethereum. RANDAO requires each validator to\nprepare by performing many thousands of hashes on some seed. Validators then publish the final hash\nduring a round and the random number is derived from every participant's entry into the game. As\nlong as one honest validator participates, the randomness is considered secure (non-economically\nviable to attack). RANDAO is optionally augmented with VDF."]}),"\n",(0,r.jsx)(n.h3,{id:"vdfs",children:"VDFs"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://vdfresearch.org/",children:"Verifiable Delay Functions"})," are computations that take a prescribed\nduration of time to complete, even on parallel computers. They produce unique output that can be\nindependently and efficiently verified in a public setting. By feeding the result of RANDAO into a\nVDF, a delay is introduced that renders any attacker's attempt at influencing the current randomness\nobsolete."]}),"\n",(0,r.jsx)(n.p,{children:"VDFs will likely be implemented through ASIC devices that need to be run separately from the other\ntypes of nodes. Although only one is enough to keep the system secure, and they will be open source\nand distributed at nearly no charge, running them is neither cheap nor incentivized, producing\nunnecessary friction for users of the blockchains opting for this method."}),"\n",(0,r.jsx)(n.h2,{id:"resources",children:"Resources"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://web.archive.org/web/20210513183118/https://forum.w3f.community/t/key-recovery-attack-on-bip32-ed25519/44",children:"Key discovery attack on BIP32-Ed25519"})," -\nArchive of forum post detailing a potential attack on BIP32-Ed25519. A motivation for transition\nto the sr25519 variant."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://research.web3.foundation/Polkadot/security/keys",children:"Account signatures and keys in Polkadot"})," -\nResearch post by Web3 researcher Jeff Burdges."]}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://bitcoin.stackexchange.com/questions/57965/are-schnorr-signatures-quantum-computer-resistant/57977#57977",children:"Are Schnorr signatures quantum computer resistant?"})}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://research.web3.foundation/Polkadot/protocols/block-production",children:"Polkadot's research on blockchain randomness and sortition"})," -\ncontains reasoning for choices made along with proofs"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.a,{href:"https://github.com/paritytech/ink/issues/57",children:"Discussion on Randomness used in Polkadot"})," - W3F\nresearchers discuss the randomness in Polkadot and when it is usable and under which assumptions."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"appendix-a-on-the-security-of-curves",children:"Appendix A: On the security of curves"}),"\n",(0,r.jsxs)(n.admonition,{title:"From the",type:"note",children:[(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"https://git.libssh.org/projects/libssh.git/tree/doc/curve25519-sha256@libssh.org.txt#n10",children:"Introduction of Curve25519"}),"\ninto ",(0,r.jsx)(n.code,{children:"libssl"})]}),(0,r.jsx)(n.p,{children:"The reason is the following: During summer of 2013, revelations from ex- consultant at [the] NSA\nEdward Snowden gave proof that [the] NSA willingly inserts backdoors into software, hardware\ncomponents and published standards. While it is still believed that the mathematics behind ECC\n(Elliptic-curve cryptography) are still sound and solid, some people (including Bruce Schneier\n[SCHNEIER]), showed their lack of confidence in NIST-published curves such as nistp256, nistp384,\nnistp521, for which constant parameters (including the generator point) are defined without\nexplanation. It is also believed that [the] NSA had a word to say in their definition. These curves\nare not the most secure or fastest possible for their key sizes [DJB], and researchers think it is\npossible that NSA have ways of cracking NIST curves. It is also interesting to note that SSH belongs\nto the list of protocols the NSA claims to be able to eavesdrop. Having a secure replacement would\nmake passive attacks much harder if such a backdoor exists."}),(0,r.jsx)(n.p,{children:"However an alternative exists in the form of Curve25519. This algorithm has been proposed in 2006 by\nDJB [Curve25519]. Its main strengths are its speed, its constant-time run time (and resistance\nagainst side-channel attacks), and its lack of nebulous hard-coded constants."})]})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},64281:(e,n,s)=>{s.d(n,{A:()=>t});const t=s.p+"assets/images/VRF_babe-12768d3392ba939b5f4c4955556d12c2.png"},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>a});var t=s(96540);const r={},i=t.createContext(r);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);